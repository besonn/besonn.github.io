<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伊维的笔记本</title>
  
  <subtitle>温故而知新</subtitle>
  <link href="http://besonn.github.io/atom.xml" rel="self"/>
  
  <link href="http://besonn.github.io/"/>
  <updated>2023-07-07T08:08:19.628Z</updated>
  <id>http://besonn.github.io/</id>
  
  <author>
    <name>Kevin Carr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些小事</title>
    <link href="http://besonn.github.io/2023/07/07/%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BA%8B/"/>
    <id>http://besonn.github.io/2023/07/07/%E4%B8%80%E4%BA%9B%E5%B0%8F%E4%BA%8B/</id>
    <published>2023-07-06T16:00:00.000Z</published>
    <updated>2023-07-07T08:08:19.628Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="41db50bb79fcb1e0b7486ea2ee60851a02ef83ac7a4e62e67cb102b364d335f5">efa7858a822b7a8283fb177503b9973eb46068b634448821122b3e0fd2a5a5e2e8b426e27faaf6f787badd069f1dc4e325d2e9432f5e2168da77d654d964c550a5cdcd6b4b086cb88e7205d1bf5ce1b6cee79536100b9725280628c3840d4dbb6c47bbfa28f1a13cfe1412077684239efbadd99760b6e03fc457bd4331aca1692d26134655d65138f6d0e743e4339276fc781d4f7723b302b46043d38f96e86628e62278d3e21a4cc674c424bebd128b8d4319e0bb59450cc4db73fd1b26bd3bb27788d2728eb713d603f7137d3807d0ec759e1c96127f811c84c6909c151516b4858ad351618ca9d92a800f78538951d6fe22ad07a0dfad50656e9d5314ca70de47f2d3e637b06fc6ad46d0dfdafe18a15f9e29c490ffef76486891f733fc651819857c9de1591f34a17352d62efe6f1689a7cc093457ce75cbb3a2dc6782d7bd03d15ac61d3c63de8b5dc91119b58045fde0e9b08ad69456e2d95438e31b8e64ba9824d257587be5ba69402c142b1f8cf4609354032e8df9f321dd63dac15945d70719ab308051876e80af848969c16e04c9e3f1589524d3f59708208f11c252b5616824240aae8c6a96e5c1a16ccdb369d719ecadb737687f27856927c0a0fc2139aa8e889152c022699a8c5a6089367b20eef9e0abdd59ee86e05a26199cf0e47c475a0e679520fec699333cbe80e980cafe6beec6fd1cf638a11a5585d5e4235e7fe8067e632c5ab7128f06d29f584f75b62c24abaef123b3c4cfdfbf156707fd6763dfd3b7f1ac0d87b51c055854d6ebcc0073acecfef919cc393b43e70afdfef010effbea02bfd8f762819ae1feb8b846c02e57c93581aee015eaaea58606a483120c3a7b676647c464fc1d365da12d511d57a8563c3f79950678ee89d8e0b48c921ec3ab1b3be94a2175ab8c020a03f58a3f9513fc9f0093a911fdb6aa149f2a3c51eeaf9aadf41b1f42c29bc211eb329a430e387a1e619a7218208d47580358c147a4e9097c472f87a57d7076b616c92e3a35029b434890fde0d58817a18c4edf9e7e6e4b1eb0fffece73cebfad4c74ba52c54305c2807a7894155209109022b9bf0f0c3dade63807bf42c8ed72b01c7d24afa5afb24ad7f8a8759565058b9bb3742af497197ab7bda4cc5f8453320a1ff14133ad448a7ad9f35f09d2e80fe29ec1a82e2f6d80387f34875d946b83a1d6ad35238e6281c376ef52243cf0aefaffc96219c62e40adecf83bab7e250c0f7e2d6a0aacc1f5ffa48081f65ef67da746cc5d4cd9fa79e8c1b3ca4dbd7c6b0c90e9575ae2d6bfe341913c62f6dfa5cb03b297518d41fd8b7eb68d019a77061f86ee3a44b3b9c17125a730ac6a6bf68d455c9c7135bc5ce5056e8a8256293edb38a5b71da34c05660f3d23024b519b58e8cf25eef62064ea46a74e70a275e4d6dc3bf8c2e7f12908933d35299035157eb09c337fedafc8271c8384ad132f11a8026825359ffe22267fa0456a7ee96128a4f88d8c5da03913ed6ba415b8f62c8f0603ca5db3f826453d0de5e8a93829cd33d2c775a6d27244861f9d78fa6a822b676b71f31b237f226fab592e2e17f2d74686e1c670b60d897321e452542df909a8ff41bd0f671ccc0712701249b1af9c33a9ffe1b74d3b0dfa513ce76c84b62617d0f51438a397407e829eb40bf1ff2f8841bb521d174fb0e9b6ed4fe731aa9f1bdd42d8da879cd8018ba9de02535b7664d34e33f41c67ab3add02c7b9f1415e3b92760a80fe7522ea41a493406ade44c60ce14cb09871d8d18948d21d0c164837691d0b36e9496401a131b32d847b671f42e9ded1f54cee80d6daa4a513d9378b13bae6ea8c8c576d9958e47549f04c1c95731589834395bd1b6aaa35fcc03263158395cf7b30d124e8bf13c22286f765326fa181fceedc6832863eb4f713a78bf2d2be9455691b6db1b314e6dd4069872b61fad671030f553ada48062d0b5198972628b3f7905e36a9e0863c9bbacfc609526dedcb4d4a6ce1875404bccb672ee051a2a9904f37f18bcedbf1e36e6d86035b4148b3d613704c65f129e7c5b55b99af569fd3e15e6577acab15975f8ffc47bfee4620bdd81e732ce8549c08ff883de8365d556c8f936344d74fb2a47dddd6c2d57e0dd4447d50268dc1a2f7fc2720b1cc9dcab594582006475003cbebb821e2dd3f237e35c33d4055ba4e9f79f21777139db63a33e3256c421abd3b848916814154e4424917b56a705a68f96827bf52326de3698c3c56a2366c021c6fe67214d1807282c7df2a1e39e1ef413961b41f326f67dcbe19ae66176e9353b79e0c5eddcb9a93876d8073bff4acf2c8bd1bcef3ed718b81da8193c5ee1b1219bb21512d12d1b82a201fed17c3591df6bca180bfe8ca13798e04460516238c5dbb2645599f8c27f58a93e0b50a67118e313d8d47e5c6b93f4d695d98bb14f9d671cece4f3d5437b054e25c22ca8f12c064fc0fd89dc485958396b9daca08ed11bcb7173369799bac9133698c8c958f6283d7eee2230cab621d32776111ed44c818dedee16a761bd8762e9b60782bd7f2ef872931cc44ebe3ee5b44ee30ee6a74c914d2c44323f403f94b7f3f834235ae2c6c6361462208b9b0d2577dc99a3cad75102d4533246fb3c4013eec9fa9dae63cd1fe274d40d58709b885e863fd54d4b49699beedff27b65a7860badace427e79e75b94b0a95b573446ad3452e48e96a4a175d075656bfa4f6fb5795aa72747de49e322e4f9e600761d895d0bb1bc52716d999cb9713f1eb33e65dc51a35d8042d63fd884ae0ef8e280886f0d7344fe3529156faf29187373206268f64fcdd1f22964f9b8c3be22e08be663bf985a4afca8082e942b7b32fca38821f3d7697960e051c95129a9cab222fc7d760ba5c4246d29f9c0c1835b34fcd190d8fcc68aeef3b8ed1395ef0d7731e85e63e5af2d5fde1f1fe4c743597a08b99cf71e63bf234cba32c45ec23d1ba759299bc3ff59a648fb2601ef1f06383393dc9c19aa2a1e93ed5a21a987230576b1ba2712351dad9979910e0ecb8fc4fef83293879804161cf49bd47e16a088a1c07eeb1ab59637d4ef4ad27e726a8b720c748febf11f0ff14c90cdce5dcfddae938d7fd17a714f0ceb233cdebf33ed46f53ed2cd287c349a363f6ee353ada9973cd6cc04db6e020ed2959467b7fca451d6dd0b609e4399bc13477040448b4b0280a6aa1105189318fd4503883773933d418e52ee5a7b695ed728c998111068dcbea897e04e64531386a78467bc8f372383047743718263e0e9e5acf7899eb20b4ad32cb0fa27547aa2679bf37c617d7d4a752a8ec45fc4940c09fcce3a62ef60bb149c2367cbce70210a2b1062f797a4ce44b33c1668d8bc584bb98f63d457806b561a5312910717264bd2ff18fc25ee0f91fc4b2384e66eca1562b6b2acdae874746385eb7647294de4dfd0a84b2ac6669e734f51089f4c630b150877e0fed352976d851f6b42c1e21bff060fa3bcd1e14922db4fb305a6ff7fbadb9f7c18e8f4b5071329facb2aa205a28d9d460ba2887885dc6c3b5d639258c7dbbdbdae49dac569c924d585f4c7a0d34dd76bd33fc27523bfcfc4fe08b296700e0a0df514073f96b1609f9f70444f8d48ecbf0d4e0a8644910a9619b8b013cd84379873e69c4a8479d387f8a34e4487ded63a4a6265d49b644b1540beb3318d4c48112263730c5b5fff8d7a50fd124730f062413eb765125cecd0867f1d7254f0de2ddf87462690f5b82abafdd8195b6c19efba25ad12e09016ccf175909230c8c4fa2f7591f4f484c662699c449375e6a3842301bad98d392c10c83d62d1af2bd01a5243f6babc4903dfe15a5d3599919b7a16ff23f977bc8b23a4e1ada437d6123605b99d8c074897a1372dd5384f83ab753bf48fc33b428867b41a5587212e13da2d73f65692c3655d38ed7c1737741cf08391b84d1369d5037c5d62ff1ff2e76e8637b8fc7b130af8b2a58d5bff76df6441c34b4d5aaa1c4d2a3d36dbaad47beea17aac45dc21e5c16d5916d5e270ffc4193821ad6bffe37d2f2aed72f7b817f6c0a9f229bcbffb1721cc9fda12fb602313daec1575042934e3ab58d705d8f7394804ebc93dd41cd332904546df8df4156554938f9fd6eed2b9ff03610579971ac9be6cb052557b26b55d6df74245e416584646ad5232d675931c07ac3c3838a85ade452dcd9dea06cf330df05ee9ce92f380e39d558f06eefae0093cb4f70411af5ff2d3090b4d73dab4c1b303ec8406eab615ecef7d0af6b6174d25275ef4b53c946df4f6bd99dd2f1bf8ed481fac34b19e89c38cd1fa621dc803bcfaf36500189c172b93545c53730db9ef393dd8b5e0848b3cca7e891a0132379ba4757ba5acc3f375eda4354feb47a2c54be073459ae91c24c77b07023e8036e6568dd170cfa9849005aa057a5da4d37b4113bb381fd5a36c60db5869b0a4c9aacb65982080469fa5fdd552b10beefab46b1c562ed96445997d45ad441b06a5bf901ecc3998588f9cd6bad1797b5459f3913fdc5c5b1e8d8eb0669476c45cdb5ac6bffbef35a8654175a18b5536deaa1eab2adade29a2b3d2ced59370b8dd648d3d1df60c31b4690dca9ddb9c1a0e89b75a779dedbc420e7755e4f33be96d919e47f6867338d06820a825160bce23a553084953924b1cde490c7ea5dd2bc49fd3a14e61eed3f69cb437ed9a2e2666857b374b7e9317d3327de9e7970ce751b2dd83541e68d2867eecb26fbd397f5c4f2cdc3a36b0bfff8c817bc721a1f4b8c622c2454c4b384e017b01fb956463af9758172de6adadb8965af34c832dcb59d73b83ddb9c371ecbc11cfeb6463fd979cd229a07a39ab7d08dcbc607fd2eef311e0a88a4de85143486c654308fbb95b82b28675f091f83f5142fff0b451ca623d210d5afa4147e86f37d833e07bdc07e367ef00c0c73d858876db1e333bfa4ee4870e4a73befa31ee144f18071d685aedf6e735d07554b123ddb91d84c368c9c76fa28fd320077e516d721ab74006cb1b8bbeaaee586e5b78fcb160bc8922a231787d230aa4f7dc6602e726d1f7b1f74d6981bb4f2e48e837b68c93a473649944572a017618c3c555d5eba57e0718a7a2072de6fe66a6cd9467e602df65dd0d61ed6823b4696cbb0071960cebb74cbbbb1073d4508dd7f6d88db27e06bbe4ed75702f016a9adf7da6040e6f0095bc232d3fc172ae2c8b15fc43c396ac612a64ac3c0993763317b140430d27bfc54b9894fc2d1d702ff19ac6ce4ff54102e347704ce2029b787fd70af4dd7d98d580fb36d957ad2b48c1f939453d73d7ec5d924ec74d75afc165f70edfbb7b489e6749dc0ef11f517d30e0648f904350a8401b8ab7bfed4f918444dddafaf195a10bfd0905b51f8a3dc56e529ae87105dde1ac52a3533905f7c09ce23cdac442e5b71491accc393e87c33d989778f6b7d6b1305abfe7b0a65b1ccd3eaa3034ae5a89e56f24c5f246c6f11d92be74c9ffc0ca51227f1e7b54a85f4e8e4b74977d852daeb4736cec33eaf596baed878d1c866b9803950b598fa0ede36e93116b8a6281714c52613e9d71a052044ba3c1e989fb985cf9f9f2b5420d1c0c806a35656b576739b7d089a5967978f0cfcf078b82e8e9828df8a603d940b85e76874c344b362a43cd556fd3955594f73fa7f8849cadba5820c54bce4d24809dab455e52b59d8f84df831533d484620238d3d52fd16863628249f7f43db7d8304293f22197e20ecc240321171409c923973addfade9af5e457fd3ed7a4c8e9f1b38dbc6c7162547f66619c3fd4a55d00e89ee8a67f2bc9781f71b2e68a8fe5aa5b1d9dfa5ce564ecce0bd00b6cce283670d8f76237817af5387c3c35aec707b70626fa509b13a446bef48ae0db064ec515f7cd69f848b7863cfc11d04bae8bb11bed7e9f802eff1315f27060168338928887dea39631b43708e935ccc0f291a97fca600db8d7ed421e194a2c2d10dae3d215c911538815801ee4650c51a1b0e855808db5112fb2b2148424d4adec664b842287ae36eb3e51f502bd9fc7ad075b43c92d4631335cd1e717a3123a31da440cbad82310404546c3017cabad13d222013c59ba2bdb64a96b8e32b631c2d7efa0f5738b85377908e7eaed464bd4aa82cbfc3cbf9159d976d6cd8a2ffd4af16306db43d4b8522ef0920618474b91e777ac5a469c7e5f76470b3b3f3cf14212b0ff9bd1c7bf1d53bf2159690b93baabaf02d07b3741573e822ffa4fc9023b16b83aa3a3d49f0527a896f953c118f140c806b48ba089bb584d293a423826c3d4b36ec7fec837e7136fa462348a8a6dfa09956850bada74c33f1590938bbd1fb6474837bfa86778b2b4d932f8fef0ea6caf08ca1ff802418adbc3f086a9afd4a37017fa8b7e1ecc8a609f47cd1b41fd093a8fef6eedfe6537fb5c5d58d327028f0df3f164dd93bda4446c748d0f8fbb13029e6dc20410870a2499fb10a980fdb82c91b5f2f574ea00c568f1fe8cc97aa3eb69154567f386d58cc1229a6d6643acd6a61a0b1d814f9a0df6a757d08795c37202d9286163c54ade5e66b408e8d23a0d7134963af4e44deab5a5349b8b1e41887c8ae81a20864eed84fd628d3f502ec4cab686e5e4a8097fc9de0eb22612ff34cce9ea6342a09aa74e70f553753221e527a5d21aae0ecdf1f6726faf1c445cc4c856b7323981b972813a8c3c74551b1f51e7b1571f15a8602d81b0d0a673702d13bc9abe446e9f04226e1d98bef81f176e400959435aaa81fc7c100a18490da5b79c0462becc4408059d542a8f462f0aa5395296838b6ca1d1ee5b3d2dfee215ceedc5136fafa3b5e3ed7583d8b8651c7ab9052cd2dd5971f10c11a44ed5c11212672fe80255dc1f4aa5b830c370fea548ab4783441241faacf6eb2454ccb9dfe575312fa65affd7493c854b340181470aab4d7507a489bb13820808f901b6cbdb5eda430a5f9891ba681d64698ae9b2642c6eca19cf873bc01034f3dba6d998c274a1011ee4366f63a23786120291b9ad43f8e0a20cefcc038879fed52a6387e42e497a7400e20e930c95bbd26867a800b0d482b7c4ab4871e2e4bc1b9e127979bbe0541bb29300608decb6f7540b7c660345957f5ef8475fda80c449d18bcdf6070eca6c3f20c2d24b88e9b9f0debb318cb3a05544d9a0b951ba872e0d73488c88d188de5355de7d5e209ecf18f20a30d49292661adea032e1c3a0e3401a59ccf1769480d0e881cc2fc4f3493f9edab8d28d36390247d8ec15d7865ce5821c454c2795ed2a0fbaf2abc5033b8f844f39b314a3248f4e41623adcf77adc0ec9620145df597ab9592158de5c98f7900c118956dcbdf7e4501c00cec7d35b7109bc8b968064e89ef099916ecda65e5806c8515bfc84c71e5afd732bb48b200a72d589669807523e4fd5ce3338513312989905edb02cee96e04842e3e0a203bf66907f8682d982f4acad1d9f91f3ae713a5030a6121bfe00358da92f4d5f34fe835dfb7879c560759373f082dc0b577bedfb533ad38b69f6d555d2516df86ec68dc6ca67990c4db7b6dfb07a618961d38525c99a5f74f1949d7b5b08f814dc065bae90e2d800c13e1359fe6d3a107db9defbf7b8c69dbc24bf91ebe1e860260e28326e55cf862f3eb8a5f9f2876fac5418aea58174f536cfde5e588263d2ecbd35eb788cffcda00c64b3815bfebe5f4097b0a58d3631d22f183627e64da857e12adcf45100afc2f56c105b1c2b3a1253e73ffa4de3ec1d721ee7a8d65c9a8041a81500c91f9f1f8204d5973c383561a86ab0138f783ee8f639fd99b1ac2ad088786d2e992f44b1643fc3918b6da9c59b7df6001f42498af2101d1f05ad0c0e213faae11d54f1d838f9ebbcc418384be76ad4f4d2604e2e3d17fcb5ae329ce4e0c32d77d0514ca2f8233ffd536974485514e0dc5abd70a2417d44a793f00ebc466bfc8ba6733914f8e2f16a752a0ca3d4bf8394761ff126478118d4a7c7b216b7b07c8294134760eda0c1e9be089772dcfe3a5abc7c96d972245560b033a417fc47cae1696a06381dce5618d6158a2f80fd7d0e39ad7d44b55eaab994b73ed29945490086acdbddaaa99f45af2c3f5160803277d994c39e0d44d9559c9442dd2962771573c9570277a060ec2b2144d4886ba5693a000965148068fbbce754e77c2a0538c1e61490bfc6c42dd646abf0a7a9a03827d1c5104b470ffb6d4d5f8b68a9c0c49541748e5a99c2ac158c45722d7b14a4adc0c9de3af80cc9bd14ba110cb34738cf78d30d790336e96ffd9a4d4e12e2c2af64e8f476e92b575a1c8d1f67024a3e24c62671cc53f4372f5c9d0dd17342cba2e0510cc25c40d24add5f8e0f01d26d7150c93efd74bba69a5a8236aa660cdf507b97b60b53c8f606b2306da2f31ea4a8f950bde21e6d7f86e4b3bb85eb75b6766a7ae9e41385c5ebe5ff5d4f490603c8aaed0dc4daa3c0d20325f935e2f113be024d0bba09b23e9e198d63cf32b14f7a08dee6a71d9edb640b8b77cbdb0bb9dac2ddb31e65d7da97658839e3907f81f5fe478f297b135ed55810e753c2387c48ac8b40dac58256c048b1a56b77b9d459d0289f428ec61564d360fce204f8cad6323de5d8b7bff19f5ce623a4f9283b32bbcc395cfa18fdd29e4f9d8d02c867d8ce755c201bf7149a31d4370de8f179d3ecf1e8749d8e3d64dafd7183fc96e6971196f3662790bc7b90e9683a0f32502380462ed6887cb25e19676da0acb462f42266b69d70d1f7db7d0e8603143eb8699708c8cbf2e749a7af3bf2f8af65b58c8618ca1329b084d99670f83909c9ccf4cb5864669267473a5c79f38d7ba77fa3cd688014c3771bdfab27bbcaab4d4bafb9089bccd1ed994af14f273575970c8e9c61436b0bcf1c5fe4e5db24dc2218601027b996b0ea43b1cd1450aea2156daa002c11d8a7f9d1e6f044229c5e4d894fe98b981104c70a3189dcfa008f3f467c6e1ac38184cbf49c6607cfcb76a1d6be4aabf2191720db23febccb1d01893f19e9fe849543e954337433ec27859c5bd290437c58d513a4f048ef1e0dc25bf03de56b85e00c729d73fe8627c1d7474e90b50b0d248c54830d4dc362d005943daabe917c61041d0f0d035ac47364b0c9fd053ae6baea552decc2f1eaf9991fb56e5349e41a234e893ff8a597977e5c848202015d80937ee6c7f9742dccc0f4400e12705a06fd9711c411c1c2385efac45ff16c3f4d4fefd22bbad235939bfee7aa8281db482ee8875aa89eb058d55e7decfe972d9da0b1a20ce0ad2083850a7faa9f7f07453d13b99f6b4c501dc88d2cdd327ce954252f9543cfb12a16e27a010f5c7179ce9b33632580f74478ecc08a2702d5d89b345d06d14444c2047ab35fc928367d242d815e63af8b592a55b809c0b722aa5d3385e65e8ad9da7018435b123b0da648c87c24b3dca1a32f4c106fd3ac77390e77fe7147b6b7e5d2824bace6529e1b155467d0d8240988792f4057a787e8da8c10a5caac97712648f5dcdada208a7145f206c3f61e2ed6ba851a8cb8b2f5ad7a3fbe0b40b16a0331d21ecb210557db76aa23ec5798e9ade33f23a2a0ed96ecad8e492759feb5a47094373daa11a8ceab888a881308140534e1afd2b0ea63f291f09ed13c9b1f460721fad8aa7e39b70209a39865f66f69e09f78e788bc90ccb73e5794d1fe19a5dc84ceed74d5d6e7aebe2a66fcd0f273819a81c558c2ed8df46602ba2be4c97c3aa2570d52fdd2ac2d5972016684c843a9c726370ae810e8d911838263ebe8edb810c8bb93ad282d3c5f37257fa86592ec42afdb21e964746b58e5c717fb25f595b2129a8284270cc7752105f48b4588959256f4557419564792e336f418cfb92b352c576c5925fb39e60d94c57df5076f28b322d978f07e838489a1131c1ed15133d011779a9a470dfcaafade084f452e508c38551eec887f4e3028567d24db3334051f89da37884849c5ac45af151d56a0c57bffef14512d9abe101443f971459f595a3cd559d1ff8aa93c2e21f70853f102231d26982f2bb71fb037f182c37ddccc8e151bc1bb95a893f242447675110ab179b15984cbb97186de5b7c48749235351b898c90e27fbcb12dd4a758167a21d650342af9ae56628cd835d18f4f95cada6799563082754302c80bc8a2eca5c0fb88e0bfdd7dcfb3c55e3860ee3e124b76bb6e4e9a1e843e472e1249a08bffe00db42f33e6fc0c6f0ef78565185e3df0dfc3d95c1c9c81ce00c738876b25e32e1ebfc744106cd0266fef91d837ee2a6fcfa945039a76762859fd17cb4476851bb48ea23ae5b79aff096df7943256331e3006b7e477c09d976676eba0253bbc7bd1c7bf9f5199629b21e2a5999eed22182edd8ded98d7dd29f1ae5355b8e02826e0496379c648185bc22ae15722c288b9470440bc4f370e84ffd35e8d3706f56cb9c5099d13407758ee7e30c88dd3fb2a6c05560d995ad8a889668a1530a7697b94e4abfeaaa63d3b63af67532a56e066f074f53ab2baf493b4664be09646e43a4d1db7ff704a860f854cb2f12877ab53d43ec690caddd2f42d9b6762f5dee3eef8dcc8d121de9a0d0d944fb460118c61343698c790eb8579d60ef74d379156da642e2f6d653b64cb84874541f59a25dce640ff40a601bea64a7d6e9853ba9b34fa4f1bccb8864a133f1bc01bf8b6d449f2869bdf5c2f3197178965922d21c9e1414c3141adfa0c63bf1b81fb6a12ccbb2daa0b56b76d6077263fd93d3acf0f895b5b59e156f9fc142d5587d2ecd49f468393f4fb7fe8764f4b22ac62ea33745c5cb86541c297b58c0110f98a74b111a9ecd5adb635e4da20ee7fc73c171f776230b2838c030ac9938ca0046190b7e1af67c3c80a93aa632679348e7f55d7c69a0f8d9f48fb993e76f2c6811366531a53f6c0ddc257d86191e7da9760cd9ab6f5166ac13b696baa1c6a655b84e5f19134dba707aa9854c53f1119cddcd60b90eedf8d29b19b35fff3d8bbaa205bafc3e07931488c7ec94774ed3bbaa2c41307050ca2e3f8090015087d360ee78eb85df19ddd6d929c46308e33d9a807b2bfe418c600cf00ab8f831211db5565c4e2143c342031521e2d1dbf2a35078f8ec18ee38b69099573bece9f4afe0649cef9612d2e3e9cd3ad65669cfb8778c318e035b6d215e1f98f4db5edca6686909f297be24e7f691514827f5de06946faec3206cf88bc834698142173dc61d7ee7dd76700c1f3d015527e858fc5c83fbdc99700f7844e124838d8e9e0fe184db45e789734a0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="随笔" scheme="http://besonn.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://besonn.github.io/2022/05/07/hello-world/"/>
    <id>http://besonn.github.io/2022/05/07/hello-world/</id>
    <published>2022-05-07T12:08:53.451Z</published>
    <updated>2023-06-29T03:52:25.127Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络自顶向下方法笔记</title>
    <link href="http://besonn.github.io/2021/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://besonn.github.io/2021/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-19T11:51:22.000Z</published>
    <updated>2022-05-07T13:46:04.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面: 这门课是我2020年秋季学期上的,当时老师要求读这本书并且做笔记,就留了一下记录.当时看的比较急, 参考了很多翻译, 也参考了这两个项目: <a href="https://github.com/vincenzobaz/Computer-Networks-Notes">阅读笔记</a>, <a href="https://github.com/HanochShi/Supplements-ComputerNetworking-ATopDownApproach-7th-ed">PPT</a>. 读完这本书之后希望可以留下一点印记, 方便以后复习.</p></blockquote><h1 id="《计算机网络－自顶向下方法》笔记"><a href="#《计算机网络－自顶向下方法》笔记" class="headerlink" title="《计算机网络－自顶向下方法》笔记"></a>《计算机网络－自顶向下方法》笔记</h1><h1 id="Chapter-2-Application-Layer"><a href="#Chapter-2-Application-Layer" class="headerlink" title="Chapter 2 Application Layer"></a>Chapter 2 Application Layer</h1><h3 id="2-1-1-Network-Application-Architectures"><a href="#2-1-1-Network-Application-Architectures" class="headerlink" title="2.1.1 Network Application Architectures"></a>2.1.1 Network Application Architectures</h3><p>network apps: e-mail/web/remote login/serch</p><p><strong>How to create a network app?</strong></p><ul><li>write programs run on different end system</li><li>commucicate over network</li><li>network-core devices do not run user applications.</li><li>applications on end systems  allows for rapid app development, propagation</li></ul><blockquote><p>与网络相关的应用应该可以在不同终端的机器上运行，并且网络核心的设备无需运行用户的程序</p></blockquote><h4 id="Application-architectures"><a href="#Application-architectures" class="headerlink" title="Application architectures"></a>Application architectures</h4><p>possible structure of applications:<br>client-server<br>peer-to-peer (P2P)</p><p><strong>Client-server architecture</strong></p><p>server: </p><ul><li>always-on host</li><li>permanent IP address</li><li>data centers for scaling</li></ul><p>clients:</p><ul><li>communicate with server</li><li>may be intermittently connected</li><li>may have dynamic IP addresses</li><li>do not communicate directly with each other</li></ul><blockquote><p>客户服务器架构，C/S模型，服务器拥有永久不变的IP地址，客户机的IP地址可能会变化，客户之间通过服务器交流</p></blockquote><p><strong>P2P architecture</strong></p><ul><li>no always-on server</li><li>arbitrary end systems directly communicate</li><li>peers request service from other peers, provide service in return to other peers</li><li>self scalability – new peers bring new service capacity, as well as new service demands</li><li>peers are intermittently connected and change IP addresses<br>complex management</li></ul><blockquote><p>点对点模式，终端之间直接相连，和服务器之间没有什么关系。相对于C/S的优势就是在于P2P应用程序提供“可扩展性”（网络负载是分布式的），它们也“具有成本效益” ，因为它们不需要大量的基础结构和服务器带宽。</p></blockquote><h3 id="2-1-2-Processes-Communicating"><a href="#2-1-2-Processes-Communicating" class="headerlink" title="2.1.2 Processes Communicating"></a>2.1.2 Processes Communicating</h3><p>In the jargon of operating systems, it’s not programs but <strong>processes</strong> that communicate. A process can be thought of as a program that is running within an end system.<br>Processes on two different end systems communicate with each other by exchanging <strong>messages</strong> across the computer network: a sending process creates and sends messages into the network, a receiving process receives these messages and possibly responds by sending messages back.</p><blockquote><p>真正进行通信的实际上是进程，在不同端系统上的进程，通过跨越计算机网络交换报文而相互通信，发送进程生成并且向网络中心发报文；接收进程接受之后可能发送回去进行响应</p></blockquote><h4 id="Client-and-Server-Processes"><a href="#Client-and-Server-Processes" class="headerlink" title="Client and Server Processes"></a>Client and Server Processes</h4><p>client process: process that initiates communication<br>server process: process that waits to be contacted</p><blockquote><p>进程中一个为client,一个为server</p></blockquote><h4 id="The-Interface-Between-the-Process-and-the-Computer-Network"><a href="#The-Interface-Between-the-Process-and-the-Computer-Network" class="headerlink" title="The Interface Between the Process and the Computer Network"></a>The Interface Between the Process and the Computer Network</h4><p><strong>Sockets</strong></p><ul><li>process sends/receives messages to/from its socket</li><li>socket analogous to door<ul><li>sending process shoves message out door</li><li>sending process relies on transport infrastructure on other side of door to deliver message to socket at receiving process</li></ul></li></ul><blockquote><p>进程通过套接字的软件接口向网络发送报文和接受报文，套接字也被称为API</p></blockquote><h4 id="Addressing-Processes"><a href="#Addressing-Processes" class="headerlink" title="Addressing Processes"></a>Addressing Processes</h4><ul><li>to receive messages, process  must have identifier</li><li>host device has unique 32-bit IP address</li><li>Q: does  IP address of host on which process runs suffice for identifying the process?<ul><li>A: no, many processes can be running on same host</li></ul></li><li>identifier includes both IP address and port numbers associated with process on host.<blockquote><p>为了向特定的目的地发送报文，目的地需要有一个地址，通常在互联网中使用IP地址，目的地端口号可以用来接受进程</p></blockquote></li></ul><h3 id="2-1-3-Transport-Services-Available-to-Applications"><a href="#2-1-3-Transport-Services-Available-to-Applications" class="headerlink" title="2.1.3 Transport Services Available to Applications"></a>2.1.3 Transport Services Available to Applications</h3><p><strong>Reliable Data Transfer</strong><br><strong>Throughput</strong><br><strong>Timing</strong><br><strong>security</strong></p><blockquote><p>运输层协议能够提供的服务：可靠数据传输、吞吐量、定时、安全性</p></blockquote><h3 id="2-1-4-Transport-Services-Provided-by-the-Internet"><a href="#2-1-4-Transport-Services-Provided-by-the-Internet" class="headerlink" title="2.1.4 Transport Services Provided by the Internet"></a>2.1.4 Transport Services Provided by the Internet</h3><h4 id="TCP-Services"><a href="#TCP-Services" class="headerlink" title="TCP Services"></a>TCP Services</h4><h4 id="UDP-Service"><a href="#UDP-Service" class="headerlink" title="UDP Service"></a>UDP Service</h4><blockquote><p>运输层提供的服务主要是TCP和UDP，后面会详细讲到<br>补充：无论是TCP还是UDP都没有加密机制，现在的SSL是安全套接字层</p></blockquote><h3 id="2-1-5-Application-Layer-Protocols"><a href="#2-1-5-Application-Layer-Protocols" class="headerlink" title="2.1.5 Application-Layer Protocols"></a>2.1.5 Application-Layer Protocols</h3><blockquote><p>http/smtp/pop3……</p></blockquote><h2 id="2-2-The-Web-and-HTTP"><a href="#2-2-The-Web-and-HTTP" class="headerlink" title="2.2 The Web and HTTP"></a>2.2 The Web and HTTP</h2><h3 id="2-2-1-Overview-of-HTTP"><a href="#2-2-1-Overview-of-HTTP" class="headerlink" title="2.2.1 Overview of HTTP"></a>2.2.1 Overview of HTTP</h3><ul><li>web page consists of objects</li><li>object can be HTML file, JPEG image, Java applet, audio file,…</li><li>web page consists of base HTML-file which includes several referenced objects</li><li>each object is addressable by a URL, e.g.,</li><li>www.someschool.edu/index.html (host name + path name)<blockquote><p>网页上包含很多对象，由html 基本文件和引用对象组成</p></blockquote></li></ul><p>HTTP: hypertext transfer protocol</p><ul><li>Web’s application layer protocol<br>client/server model<ul><li>client: browser that requests, receives, (using HTTP protocol) and “displays” Web objects </li><li>server: Web server sends (using HTTP protocol) objects in response to requests</li></ul></li></ul><p>uses TCP:</p><ul><li>client initiates TCP connection (creates socket) to server,  port 80</li><li>server accepts TCP connection from client</li><li>HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server)</li><li>TCP connection closed</li></ul><blockquote><p>HTTP 主要使用TCP作为支撑运输协议，端口号是80，TCP为HTTP提供可靠的数据传输服务。</p></blockquote><ul><li>HTTP is “stateless”</li></ul><blockquote><p>HTTP 是无状态协议，因为它不保存用户的任何信息，并且基于C/S模式的。</p></blockquote><h4 id="HTTP-with-Non-Persistent-Connections"><a href="#HTTP-with-Non-Persistent-Connections" class="headerlink" title="HTTP with Non-Persistent Connections"></a>HTTP with Non-Persistent Connections</h4><ul><li>at most one object sent over TCP connection<br>connection then closed</li><li>downloading multiple objects required multiple connections</li></ul><h4 id="HTTP-with-Persistent-Connections"><a href="#HTTP-with-Persistent-Connections" class="headerlink" title="HTTP with Persistent Connections"></a>HTTP with Persistent Connections</h4><ul><li>multiple objects can be sent over single TCP connection between client, server</li></ul><blockquote><p>HTTP 分为非持续连接和持续连接两种方式，前者一次只能通过TCP传递一个对象，后者可一次多个</p></blockquote><h3 id="2-2-3-HTTP-Message-Format"><a href="#2-2-3-HTTP-Message-Format" class="headerlink" title="2.2.3 HTTP Message Format"></a>2.2.3 HTTP Message Format</h3><p>Two types of HTTP messages:</p><h4 id="HTTP-Request-Message"><a href="#HTTP-Request-Message" class="headerlink" title="HTTP Request Message"></a>HTTP Request Message</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla/5.0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure><ul><li>Ordinary ASCII text</li><li>First line: <strong>request line</strong></li><li>Other lines: <strong>header lines</strong></li><li>the first lines has 3 fields: method field, URL field, HTTP version field:<ul><li>method field possible values: <code>GET, POST, HEAD, PUT, DELETE</code></li></ul></li></ul><blockquote><p>HTTP 请求报文，第一行是请求行，后面是首部行，请求行分为方法字段、URL字段、HTTP版本字段，方法字段包括：GET/POST/HEAD/PUT/DELETE<br>首部行后面有个实体体，使用GET方法实体体为空，POST时才使用，HTTP客户常常使用POST，提交表单使用GET</p></blockquote><h4 id="HTTP-Response-Message"><a href="#HTTP-Response-Message" class="headerlink" title="HTTP Response Message"></a>HTTP Response Message</h4><p>A typical HTTP response message:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: ...</span><br><span class="line">Server: ...</span><br><span class="line">Last-Modified: ...</span><br><span class="line">Content-Length: ...</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">(data data data data data ...)</span><br></pre></td></tr></table></figure><ul><li>Status line: protocol version, status code, corresponding status message</li><li>six header lines:<ul><li>the connection will be closed after sending the message<ul><li>date and time when the response was created (when the server retrieves the object from the file system, insert object in the message, sends the response message)</li><li>Type of the server / software</li><li>Last modified: useful for object caching</li><li>Content-Length: number of bytes in the object</li><li>Content-Type</li></ul></li></ul></li><li>entity body: contains the requested object itself (data)</li></ul><p>Some common status codes:</p><ul><li><code>200 OK</code>: request succeeded, information returned</li><li><code>301 Moved Permanently</code>: the object has moved, the new location is specified in the header of the response</li><li><code>400 Bad Request</code>: generic error code, request not understood</li><li><code>404 Not Found</code>: The requested document doesn’t exist on the server</li><li><code>505 HTTP Version Not Supported</code>: The requested HTTP protocol version is not supported by the server</li></ul><blockquote><p>HTTP 响应报文，和前面对应首部行的六个部分，不做翻译了</p></blockquote><h3 id="2-2-4-User-Server-Interaction-Cookies"><a href="#2-2-4-User-Server-Interaction-Cookies" class="headerlink" title="2.2.4 User-Server Interaction: Cookies"></a>2.2.4 User-Server Interaction: Cookies</h3><p>Cookies<br>1) cookie header line of HTTP response message<br>2) cookie header line in next HTTP request message<br>3) cookie file kept on user’s host, managed by user’s browser<br>4) back-end database at Web site</p><blockquote><p>服务器创建一个唯一的标识号，并在数据库中创建一个由该标识号索引的条目<br>server响应用户的浏览器，包括标头中的内容：“ Set-cookie：标识号”<br>浏览器会将服务器的主机名和标识号标头附加到cookie文件中<br>每次浏览器请求页面时，它都会查询cookie文件，提取站点的标识号，并在cookie标头行中添加该标识号</p></blockquote><p>Therefore <strong>cookies can be used to create a user session layer on top of stateless HTTP</strong>.</p><blockquote><p>简而言之，cookie 可以让服务器在用户和应用程序的交流过程中标识用户</p></blockquote><h3 id="2-2-5-Web-Caching"><a href="#2-2-5-Web-Caching" class="headerlink" title="2.2.5 Web Caching"></a>2.2.5 Web Caching</h3><p>A <strong>Web cache</strong>, also called <strong>proxy server</strong> is a network entity that satisfies HTTP requests on behalf of an origin Web server. It has its own disk storage and keeps copies of recently requested objects in this storage.</p><ol><li>The browser establishes a TCP connection to the web cache, sending an HTTP request for the object to the Web cache.</li><li>The web cache checks to see if it has a copy of the object stored locally. If yes, it will return it within an HTTP response message to the browser.</li><li>If not, the Web cache opens a TCP connection to the origin server, which responds with the requested object.</li><li>The Web caches receives the object, stores a copy in its storage and sends a copy, within an HTTP response message, to the browser over the existing TCP connection.</li></ol><blockquote><p>Web cache 也叫代理服务器，它拥有自己的磁盘存储空间，可以在存储空间中保存最近请求过的对象的副本。生成情况如上解释，不翻译了。<br>Web cache 是服务器同时又是客户，当接受浏览器的请求回应时，他是服务器，当向初始服务器发出请求并接受响应时，它是客户。<br>总而言之，它可以加快用户访问相同页面的速度。</p></blockquote><h3 id="2-2-6-The-Conditional-GET"><a href="#2-2-6-The-Conditional-GET" class="headerlink" title="2.2.6 The Conditional GET"></a>2.2.6 The Conditional <code>GET</code></h3><blockquote><p>没太看懂这个要干嘛</p></blockquote><h2 id="2-4-Electronic-mail"><a href="#2-4-Electronic-mail" class="headerlink" title="2.4 Electronic mail"></a>2.4 Electronic mail</h2><p>Three major components: </p><ul><li>user agents </li><li>mail servers </li><li>simple mail transfer protocol: SMTP</li></ul><p>User Agent</p><ul><li>a.k.a. “mail reader”</li><li>composing, editing, reading mail messages</li><li>e.g., Outlook, Thunderbird, iPhone mail client</li><li>outgoing, incoming messages stored on server</li></ul><p>mail servers:</p><ul><li>mailbox contains incoming messages for user</li><li>message queue of outgoing (to be sent) mail messages</li><li>SMTP protocol between mail servers to send email messages<ul><li>client: sending mail server</li><li>“server”: receiving mail server</li></ul></li></ul><blockquote><p>发送邮件的三大要素。其中最重要的是SMTP协议。</p></blockquote><h3 id="2-4-1-SMTP"><a href="#2-4-1-SMTP" class="headerlink" title="2.4.1 SMTP"></a>2.4.1 SMTP</h3><ul><li>uses TCP to reliably transfer email message from client to server, port 25</li><li>direct transfer: sending server to receiving server</li><li>three phases of transfer<ul><li>handshaking (greeting)</li><li>transfer of messages</li><li>closure</li></ul></li><li>command/response interaction (like HTTP)<ul><li>commands: ASCII text</li><li>response: status code and phrase</li></ul></li><li>messages must be in 7-bit ASCI</li></ul><blockquote><p>SMTP 只能采用简单的7比特传输，依靠TCP协议提供可靠传输，并且一般不使用中间邮件服务器，由两地的服务器直接相连。</p></blockquote><p>SMTP: final words</p><ul><li>SMTP uses persistent connections</li><li>SMTP requires message (header &amp; body) to be in 7-bit ASCII</li><li>SMTP server uses CRLF.CRLF to determine end of message</li></ul><blockquote><p>SMTP 持续连接，靠7bit ASCII码传输，依靠CRLF.CRLF结尾</p></blockquote><h3 id="2-4-2-comparison-with-HTTP"><a href="#2-4-2-comparison-with-HTTP" class="headerlink" title="2.4.2 comparison with HTTP"></a>2.4.2 comparison with HTTP</h3><p>HTTP: pull<br>SMTP: push<br>both have ASCII command/response interaction, status codes<br>HTTP: each object encapsulated in its own response message<br>SMTP: multiple objects sent in multipart message</p><blockquote><p>HTTP:用户使用HTTP从该服务器上拉取信息；SMTP：推协议，把文件推向接受文件服务器。</p></blockquote><h3 id="2-4-3-Mail-message-format"><a href="#2-4-3-Mail-message-format" class="headerlink" title="2.4.3 Mail message format"></a>2.4.3 Mail message format</h3><p>SMTP: protocol for exchanging email messages<br>RFC 822: standard for text message format:</p><ul><li>header lines, e.g.,<ul><li>To:</li><li>From:</li><li>Subject:<br>different from SMTP MAIL FROM, RCPT TO: commands!</li></ul></li><li>Body: the “message” <ul><li>ASCII characters only</li></ul></li></ul><h3 id="2-4-4-Mail-access-protocols"><a href="#2-4-4-Mail-access-protocols" class="headerlink" title="2.4.4 Mail access protocols"></a>2.4.4 Mail access protocols</h3><ul><li>SMTP: delivery/storage to receiver’s server<br>mail access protocol: retrieval from server</li><li>POP: Post Office Protocol [RFC 1939]: authorization, download <ul><li>IMAP: Internet Mail Access Protocol [RFC 1730]: more features, including manipulation of stored messages on server</li><li>HTTP: gmail, Hotmail, Yahoo! Mail, etc.<blockquote><p>POP3按照3个阶段工作：特许、事务处理以及更新</p></blockquote></li></ul></li></ul><h2 id="2-5-DNS-The-Internet’s-Directory-Service"><a href="#2-5-DNS-The-Internet’s-Directory-Service" class="headerlink" title="2.5 DNS - The Internet’s Directory Service"></a>2.5 DNS - The Internet’s Directory Service</h2><p>One identifier for a host is its <strong>hostname</strong> [<code>cnn.com</code>, <code>www.yahoo.com</code>]. Hostnames are mnemonic and therefore used by humans. Hosts are also identified by <strong>IP addresses</strong>.</p><blockquote><p>Internet上的主机也需要也可以用很多方式来进行标识，除了使用IP地址，还可以使用DNS</p></blockquote><h3 id="2-5-1-Services-provided-by-DNS"><a href="#2-5-1-Services-provided-by-DNS" class="headerlink" title="2.5.1 Services provided by DNS"></a>2.5.1 Services provided by DNS</h3><p>Routers and use IP addresses. The Internet’s <strong>domain name system (DNS)</strong> translates hostnames to IP addresses. The DNS is:</p><ol><li>A distributed database implemented in a hierarchy of <strong>DNS Servers</strong></li><li>An application-layer protocol that allows hosts to query the distributed database.</li></ol><p><strong>DNS runs over UDP and uses port 53</strong><br>It is often employed by other application-layer protocols (HTTP, FTP…) to translate user-supplied hostnames to IP addresses.</p><blockquote><p>DNS 实际上是一个域名系统，是有一个分层的DNS服务器实现的分布式数据库。<br>DNS运行在UDP上，使用53号端口</p></blockquote><p>How it works:</p><ul><li>The user machine runs the client side of the DNS application</li><li>The browser extracts <code>www. xxxxx . xxx</code> from the URL and passes the hostname to the client side of the DNS application</li><li>The DNS sends a query containing the hostname to a DNS server</li><li>The DNS client eventually receives a reply including the IP address for the hostname</li><li>The browser can initiate a TCP connection.</li></ul><p><strong>DNS adds an additional delay</strong></p><blockquote><p>DNS 的工作流程如上，不翻译了。但是可以看到的是，DNS给网络带来了额外的时延。</p></blockquote><h3 id="2-5-2-Overview-of-How-DNS-Works"><a href="#2-5-2-Overview-of-How-DNS-Works" class="headerlink" title="2.5.2 Overview of How DNS Works"></a>2.5.2 Overview of How DNS Works</h3><p>From the perspective of the invoking application in the user’s host, DNS is a black box providing a simple, straightforward translation service.<br>Having one single global DNS server would be simple, but it’s not realistic because it would a <strong>single point of failure</strong>, it would have an impossible <strong>traffic volume</strong>, it would be <strong>geographically too distant</strong> from some querying clients, its <strong>maintenance</strong> would be impossible.</p><blockquote><p>DNS 像是一个黑盒子，它可以很方便的让用户在主机上调用应用程序<br>但是它也会出现以上的问题。</p></blockquote><p>three classes of DNS servers：</p><ul><li><strong>Root DNS servers</strong></li><li><strong>Top-level domain (TLD) servers</strong></li><li><strong>Authoritative DNS servers</strong></li></ul><h4 id="DNS-caching"><a href="#DNS-caching" class="headerlink" title="DNS caching"></a>DNS caching</h4><h3 id="2-5-3-DNS-Records-and-Messages"><a href="#2-5-3-DNS-Records-and-Messages" class="headerlink" title="2.5.3 DNS Records and Messages"></a>2.5.3 DNS Records and Messages</h3><p>A resource record is a four-tuple that contains the fields: <code>(Name, Value, Type, TTL)</code><br><code>TTL</code> is the time to live of the resource record (when a resource should be removed from a cache). The meaning of <code>Name</code> and <code>Value</code> depend on <code>Type</code>:</p><div class="table-container"><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>A</td><td>a hostname</td><td>IP address</td></tr><tr><td>NS</td><td>a domain (foo.com)</td><td>hostname of an  authoritative DNS server which knows how to obtain the IP addresses for hosts in the domain. Used to route queries further along in the query chain</td></tr><tr><td>CNAME</td><td>a alias name</td><td>canonical hostname for the name in Name</td></tr><tr><td>MX</td><td>alias hostname</td><td>canonical hostname of a mail server that has an alias hostname Name      </td></tr></tbody></table></div><blockquote><p>根据分类，DNS记录按照以上的四元组来进行分类。</p></blockquote><h4 id="DNS-Messages"><a href="#DNS-Messages" class="headerlink" title="DNS Messages"></a>DNS Messages</h4><p>The only types of DNS messages are DNS queries and reply messages. They have the same format:</p><ul><li>first 12 bytes in the <em>header section</em>: 16-bit number identifying the query, which will be copied into the reply query so that the client can match received replies with sent queries. 1 bit query/reply flag (0 query, 1 reply). 1 bit flag authoritative flag set in reply messages when DNS server is an authoritative for a queried name. 1 bit recursion flag if the client desires that the server performs recursion when it doesn’t have a record, 1 bit recursion-available field is set in the reply if the DNS server supports recursion</li><li><em>question section</em>: information about the query: name field containing the name being queried, type field</li><li><em>answer section</em>: resource records for the name originally queried: Type, Value, TTL. Multiple RRs can be returned if the server has multiple IP addresses</li><li><em>authority section</em>: records for other authoritative servers.</li><li><em>additional section</em>: other helpful records: canonical hostnames…</li></ul><h4 id="Inserting-Records-into-the-DNS-Database"><a href="#Inserting-Records-into-the-DNS-Database" class="headerlink" title="Inserting Records into the DNS Database"></a>Inserting Records into the DNS Database</h4><p>We created a new company. Next we register th domain name <code>newcompany.com</code> at a registrar. A <strong>registrar is a commercial entity that verifies the uniqueness of the domain name, enters it into the DNS database and collects a small fee for these services</strong>. When we register the address, <strong>we need the provide the registrar with the IP address of our primary and secondary authoritative DNS servers</strong>, that will make sure that a Type NS and a Type A records are entered into the TLD com servers for our two DNS servers.</p><h5 id="Focus-on-security-DNS-vulnerabilities"><a href="#Focus-on-security-DNS-vulnerabilities" class="headerlink" title="Focus on security: DNS vulnerabilities"></a>Focus on security: DNS vulnerabilities</h5><ul><li>DDoS bandwidth-flooding attack</li><li>MITM: the mitm answers queries with false replies tricking the user into connecting to another server.</li><li>The DNS infrastructure can be used to launch a DDoS attack against a targeted host</li></ul><p>To date, there hasn’t been an attack that that has successfully impeded the DNS service, DNS has demonstrated itself to be surprisingly robust against attacks. However there have been successful reflector attacks, these can be addressed by appropriate configuration of DNS servers.</p><h2 id="2-6-Peer-to-Peer-Applications"><a href="#2-6-Peer-to-Peer-Applications" class="headerlink" title="2.6 Peer-to-Peer Applications"></a>2.6 Peer-to-Peer Applications</h2><h3 id="2-6-1-File-Distribution"><a href="#2-6-1-File-Distribution" class="headerlink" title="2.6.1 File Distribution"></a>2.6.1 File Distribution</h3><h4 id="Pure-P2P-architecture"><a href="#Pure-P2P-architecture" class="headerlink" title="Pure P2P architecture"></a>Pure P2P architecture</h4><ul><li>no always-on server</li><li>arbitrary end systems directly communicate</li><li>peers are intermittently connected and change IP addresses</li></ul><blockquote><p>P2P的体系结构不是一直与服务器相连，终端和终端之间相连，可以改变IP地址</p><p>关于服务器端和客户端的叙述，在前面已经提到了，在这里不再详细做笔记了。</p></blockquote><h4 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client-Server"></a>Client-Server</h4><p>The server must transmit one copy of the file to <em>N</em> peers, thus it transmits <em>NF </em>bits. The time to distribute the file is at least <strong>NF/u_s</strong>.<br>Denote $d_min = min{ d_i }$ the link with the slowest download rate cannot obtain all <em>F</em> bits in less than $F/d_min$ seconds<br>Therefore:</p><script type="math/tex; mode=display">D_{cs} \geq \max \left\{ \frac{NF}{u_s} , \frac{F}{d_min} \right\}</script><h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p>When a peer receives some file data, it can use its own upload capacity to redistribute the data to other peers.</p><ul><li>At the beginning of the distribution only the server has the file. It must send all the bits at least once. $D \geq F/u_s$</li><li>The peer with the lowest download rate cannot obtain all <em>F</em> bits of the file in less than $F/d_min $ seconds.</li><li>The total upload capacity of the system is equal to the summation of the upload rates of the server and of all the peers. The system must upload <em>F</em> bits to <em>N</em> peers, thus delivering a total of <em>NF</em> bits which can’t be done faster that $u_total$.</li></ul><p>We obtain:</p><script type="math/tex; mode=display">D_{P2P} = \max \left\{ \frac{F}{u_s} , \frac{F}{d_{min}} , \frac{NF}{u_s + \sum_{i=1}^N u_j} \right\}</script><h1 id="Chapter-3-Transport-Layer"><a href="#Chapter-3-Transport-Layer" class="headerlink" title="Chapter 3 Transport Layer"></a>Chapter 3 Transport Layer</h1><h2 id="3-1-Introduction-and-Transport-Layer-Services"><a href="#3-1-Introduction-and-Transport-Layer-Services" class="headerlink" title="3.1 Introduction and Transport-Layer Services"></a>3.1 Introduction and Transport-Layer Services</h2><h3 id="3-1-1-Relationship-Between-Transport-and-Network-Layers"><a href="#3-1-1-Relationship-Between-Transport-and-Network-Layers" class="headerlink" title="3.1.1 Relationship Between Transport and Network Layers"></a>3.1.1 Relationship Between Transport and Network Layers</h3><p>A transport-layer protocol provides logical communication between <strong><em>processes</em></strong> running on different hosts. Whereas a network-layer protocol provides logical communication between <strong><em>hosts</em></strong>.</p><h3 id="3-1-2-Internet-transport-layer-protocols"><a href="#3-1-2-Internet-transport-layer-protocols" class="headerlink" title="3.1.2 Internet transport-layer protocols"></a>3.1.2 Internet transport-layer protocols</h3><ul><li>reliable, in-order delivery (TCP)<ul><li>congestion control </li><li>flow control</li><li>connection setup</li></ul></li><li>unreliable, unordered delivery: UDP<ul><li>no-frills extension of “best-effort” IP</li></ul></li><li>services not available: <ul><li>delay guarantees</li><li>bandwidth guarantees</li></ul></li></ul><blockquote><p>IP的服务模型是尽力而为交付服务，它尽最大的努力在通信的主机之间交付报文段，但它并不做任何确认。IP也被称为不可靠服务<br>UDP和TCP的责任是，将两个端系统间IP的交付服务拓展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间的交付被称为运输层的多路复用和多路分解。TCP还提供多路复用与多路分解。</p></blockquote><h2 id="3-2-Multiplexing-and-Demultiplexing"><a href="#3-2-Multiplexing-and-Demultiplexing" class="headerlink" title="3.2 Multiplexing and Demultiplexing"></a>3.2 Multiplexing and Demultiplexing</h2><p>multiplexing at sender:<br>handle data from multiple<br>sockets, add transport header (later used for demultiplexing)</p><p>demultiplexing at receiver:<br>use header info to deliver<br>received segments to correct<br>socket</p><blockquote><p>将运输层报文段中的数据交付到正确的套接字的工作成为多路分解<br>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息生成报文段，然后传递到网络层，这叫做多路复用</p></blockquote><p>How demultiplexing works:</p><ul><li>host receives IP datagrams<ul><li>each datagram has source IP address, destination IP address</li><li>each datagram carries one transport-layer segment</li><li>each segment has source, destination port number </li></ul></li><li>host uses IP addresses &amp; port numbers to direct segment to appropriate socket</li></ul><h4 id="Connectionless-Multiplexing-and-Demultiplexing"><a href="#Connectionless-Multiplexing-and-Demultiplexing" class="headerlink" title="Connectionless Multiplexing and Demultiplexing"></a>Connectionless Multiplexing and Demultiplexing</h4><p>A UDP socket is fully identified by the <strong>two-tuple</strong>:<br><code>(destination IP address , destination port number)</code></p><blockquote><p>一个UDP套接字是由一个二元组来全面标识的，该二元组包含一个目的IP地址和一个目的端口号</p></blockquote><h4 id="Connection-oriented-Multiplexing-and-Demultiplexing"><a href="#Connection-oriented-Multiplexing-and-Demultiplexing" class="headerlink" title="Connection-oriented Multiplexing and Demultiplexing"></a>Connection-oriented Multiplexing and Demultiplexing</h4><p>A TCP socket is identified by the <strong>four-tuple</strong>:<br><code>(source IP address, source port number, destination IP address, destination port number)</code><br>When a TCP segment arrives from the network to a host, the <strong>host uses all four values to demultiplex the segment to the appropriate socket</strong>.</p><blockquote><p>TCP套接字是由一个四元组（源IP，源端口号，目的IP地址，目的端口号）</p></blockquote><p>Routine:</p><ul><li>The TCP server application always has a <strong>welcoming socket</strong> that waits for connection establishment requests from TCP clients on port number <code>X</code></li><li>The TCP client creates a socket and sends a connection <strong>establishment request</strong> (a TCP segment including destination port, source port number and <em>a special connection-establishment bit set in the TCP header</em>)</li><li>The server OS receives the incoming connection-request segment on port <code>X</code>, it locates the server process that is waiting to accept a connection on port number <code>X</code>, then creates <strong>a new socket</strong> which will be identified by<br><code>(source port number in the segment (cleint), IP address of source host (client), the destination port number in the segment (its own), its own IP address)</code></li><li>With the TCP connection in place, client and server can now send data to each other</li></ul><blockquote><p>服务器可能支持许多同时进行的TCP连接套接字，每个套接字都连接到一个进程，并且每个套接字都由其自己的四元组标识。<br>当TCP段到达主机时，所有四个字段用于将段解复用到相应的套接字。</p></blockquote><h2 id="3-3-Connectionless-Transport-UDP"><a href="#3-3-Connectionless-Transport-UDP" class="headerlink" title="3.3 Connectionless Transport: UDP"></a>3.3 Connectionless Transport: UDP</h2><ul><li>“no frills,” “bare bones” Internet transport protocol</li><li>“best effort” service, UDP segments may be:<ul><li>lost</li><li>delivered out-of-order to app</li></ul></li><li>connectionless:<ul><li>no handshaking between UDP sender, receiver</li><li>each UDP segment handled independently of others</li></ul></li></ul><blockquote><p>UDP除了复用/分解功能以及少量的差错检测之外，它几乎没有对IP增加别的东西。使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有握手。</p></blockquote><p>UDP use:</p><ul><li>streaming multimedia apps (loss tolerant, rate sensitive)</li><li>DNS</li><li>SNMP<br>reliable transfer over UDP: </li><li>add reliability at application layer</li><li>application-specific error recovery!</li></ul><h3 id="3-3-1-UDP-Segment-Structure"><a href="#3-3-1-UDP-Segment-Structure" class="headerlink" title="3.3.1 UDP Segment Structure"></a>3.3.1 UDP Segment Structure</h3><p>The UDP header has only four fields, each consisting of two bytes: </p><ul><li><code>source port number</code></li><li><code>destination port number</code></li><li><code>checksum</code> (used for error detection.)</li><li><code>length</code> (which specifies the number of bytes in the UDP segment, header + data)</li></ul><p>This <code>length</code> field is needed since the size of the data field may differ from one UDP segment to the next.</p><blockquote><p>关于UDP报文段结构的解释</p></blockquote><h3 id="3-3-2-UDP-Checksum"><a href="#3-3-2-UDP-Checksum" class="headerlink" title="3.3.2 UDP Checksum"></a>3.3.2 UDP Checksum</h3><p>UDP implements error detection according to the <strong>end-end principle</strong>: certain functionality (error detection in this case) must be implemented on an end-end basis: “functions placed at the lower levels may be redundant or of little value when compared to the cost of providing them at the higher level”.</p><blockquote><p>UDP 检验和提供了差错检测功能，检验和用于确定当UDP报文段从源到目的地移动时，其中的比特是否发生了变化。</p></blockquote><h2 id="3-4-Principles-of-Reliable-Data-Transfer"><a href="#3-4-Principles-of-Reliable-Data-Transfer" class="headerlink" title="3.4 Principles of Reliable Data Transfer"></a>3.4 Principles of Reliable Data Transfer</h2><h3 id="3-4-1-Building-a-Reliable-Data-Transfer-Protocol"><a href="#3-4-1-Building-a-Reliable-Data-Transfer-Protocol" class="headerlink" title="3.4.1 Building a Reliable Data Transfer Protocol"></a>3.4.1 Building a Reliable Data Transfer Protocol</h3><h3 id="3-4-2-Pipelined-Reliable-Data-Transfer-Protocols"><a href="#3-4-2-Pipelined-Reliable-Data-Transfer-Protocols" class="headerlink" title="3.4.2 Pipelined Reliable Data Transfer Protocols"></a>3.4.2 Pipelined Reliable Data Transfer Protocols</h3><p>In today’s high-speed networks stop-and-wait protocols are simply not tolerable: we  cannot send one packet and wait for the ACK and then send the second one, it is inefficient as we can see computing the <strong>utilization of the channel</strong>:</p><script type="math/tex; mode=display">U = \frac{L/R}{RTT+ L/R}</script><blockquote><p>解决方案很简单：允许发送者发送多个数据包，而不必等待确认，而不是以停止等待的方式操作。由于可以将许多传输中的收发程序包可视化为填充管道，因此该技术称为“流水线”。</p></blockquote><h3 id="3-4-3-Go-Back-N-GBN"><a href="#3-4-3-Go-Back-N-GBN" class="headerlink" title="3.4.3 Go-Back-N (GBN)"></a>3.4.3 Go-Back-N (GBN)</h3><ul><li>k-bit seq # in pkt header</li><li>“window” of up to N, consecutive unack’ed pkts allowed</li><li>ACK(n): ACKs all pkts up to, including seq # n - “cumulative ACK”<ul><li>may receive duplicate ACKs (see receiver)</li></ul></li><li>timer for oldest in-flight pkt</li><li>timeout(n): retransmit packet n and all higher seq # pkts in window</li></ul><blockquote><p>GBN 允许发送方发送N个数据包（发送方窗口大小= N ），接收方具有大小为 1 的窗口。<br>在Go-Back-N协议中，确认是“累积的”：如果发送方收到ACK3，他将知道从0到3的所有数据包都已收到，即使没有收到ACK2。</p></blockquote><h3 id="3-4-4-Selective-Repeat"><a href="#3-4-4-Selective-Repeat" class="headerlink" title="3.4.4 Selective Repeat"></a>3.4.4 Selective Repeat</h3><ul><li>receiver individually acknowledges all correctly received pkts<ul><li>buffers pkts, as needed, for eventual in-order delivery to upper layer</li></ul></li><li>sender only resends pkts for which ACK not received<ul><li>sender timer for each unACKed pkt</li></ul></li><li>sender window<ul><li>N consecutive seq #’s</li><li>limits seq #s of sent, unACKed pkts</li></ul></li></ul><blockquote><p>选择性重复通过使发送方仅重新发送它怀疑在接收方错误接收的数据包的方式来避免不必要的重传：<br>个人确认（与累积确认相反）。<br>发送方窗口大小= N，接收方窗口站点=N。<br>发送方在其窗口中的每个数据包都有一个计时器。发生超时时，仅重新发送丢失的数据包。<br>接收器缓冲乱序数据包。</p></blockquote><h2 id="3-5-Conncetion-Oriented-Transport-TCP"><a href="#3-5-Conncetion-Oriented-Transport-TCP" class="headerlink" title="3.5 Conncetion-Oriented Transport: TCP"></a>3.5 Conncetion-Oriented Transport: TCP</h2><h3 id="3-5-1-The-TCP-Connection"><a href="#3-5-1-The-TCP-Connection" class="headerlink" title="3.5.1 The TCP Connection"></a>3.5.1 The TCP Connection</h3><h3 id="3-5-2-TCP-Segment-Structure"><a href="#3-5-2-TCP-Segment-Structure" class="headerlink" title="3.5.2 TCP Segment Structure"></a>3.5.2 TCP Segment Structure</h3><ul><li>32 bit sequence number and acknowledgement number necessary for reliable data transmission<ul><li>16 bit <strong>receive window</strong> used for flow control, indicates the number of bytes that a receiver is willing to accept</li><li>4 bit <strong>header length field</strong>. The TCP header can be of a variable length due to the TCP options field (usually empty therefore usual length is 20 bytes)</li><li><strong>options field</strong> used to negotiate MSS or as a window scaling factor for use in high speed networks.</li><li><strong>flag field</strong>: 6 bits:<ol><li>ACK used to indicate that the value carried in the acknowledgement field is valid, that is the segment contains an acknowledgement for a segment that has been successfully received.<ol><li>,  3. and 4. <strong>RST, SYN, FIN</strong> for connection setup and teardown</li><li><strong>PSH</strong> indicates that the receiver should pass the data to upper layer immediately</li><li>URG indicates that there is data in the segment that the sending side upper layer has marked as urgent.<blockquote><p>TCP 报文段由首部字段和一个数据字段组成。MSS限制了报文段数据字段的最大长度。首部包括源端口号和目的端口号，还包含了检验和字段。</p></blockquote></li></ol></li></ol></li></ul></li></ul><h4 id="Sequence-Numbers-and-Acknowledgment-Numbers"><a href="#Sequence-Numbers-and-Acknowledgment-Numbers" class="headerlink" title="Sequence Numbers and Acknowledgment Numbers"></a>Sequence Numbers and Acknowledgment Numbers</h4><p>TCP views data as <em>an unstructured, but ordered, stream of bytes</em> and TCP’s use of sequence numbers reflects this view: sequence numbers are over the stream of bytes and not over the series of transmitted segments.</p><p>TCP is said to provide <strong>cumulative acknowledgements</strong>: if sender receives ACK 536 he will know that all the bytes from 0 to 535 have been well received.</p><blockquote><p>累计确认，建议还是看课本上的例子帮助理解。</p></blockquote><h3 id="3-5-3-Round-Trip-Time-Estimation-and-Timeout"><a href="#3-5-3-Round-Trip-Time-Estimation-and-Timeout" class="headerlink" title="3.5.3 Round-Trip Time Estimation and Timeout"></a>3.5.3 Round-Trip Time Estimation and Timeout</h3><p>Q: how to set TCP timeout value?</p><ul><li>longer than RTT<ul><li>but RTT varies</li></ul></li><li>too short: premature timeout, unnecessary retransmissions</li><li>too long: slow reaction to segment loss</li></ul><p>Q: how to estimate RTT?</p><ul><li>SampleRTT: measured time from segment transmission until ACK receipt<ul><li>ignore retransmissions</li></ul></li><li>SampleRTT will vary, want estimated RTT “smoother”<ul><li>average several recent measurements, not just current SampleRTT</li></ul></li></ul><p>EstimatedRTT = (1- $\alpha$)<em>EstimatedRTT + $\alpha$</em>SampleRTT</p><ul><li>exponential weighted moving average</li><li>influence of past sample decreases exponentially fast</li><li>typical value: $\alpha$ = 0.125</li></ul><p>It is also useful to having an estimate of the <em>variability of the RTT</em>. We can measure how much <code>SampleRTT</code> typically deviates from <code>EstimatedRTT</code>:</p><p><code>DevRTT = (1 - b) * DevRTT + b* | SampleRTT - EstimatedRTT |</code></p><p>We note that this is an EWMA of the difference of estimated and last measured RTT. The recommended value for b is b = 0.25</p><blockquote><p>估计往返时间的计算</p></blockquote><h3 id="3-5-4-Reliable-Data-Transfer"><a href="#3-5-4-Reliable-Data-Transfer" class="headerlink" title="3.5.4 Reliable Data Transfer"></a>3.5.4 Reliable Data Transfer</h3><ul><li>TCP creates rdt service on top of IP’s unreliable service<ul><li>pipelined segments</li><li>cumulative acks</li><li>single retransmission timer</li></ul></li><li>retransmissions  triggered by:<ul><li>timeout events</li><li>duplicate acks</li></ul></li></ul><blockquote><p>TCP在IP不可靠的服务之上创建了可靠数据传送服务。<br>举一个例子<br>从应用程序层接收到数据后，TCP会将其封装在一个网段中，然后传递给该网段到IP。如果计时器未在其他段上运行，则当该段传递到IP时，TCP将启动该计时器，计时器到期间隔为“ TimeoutInterval”<br>2.如果发生超时，TCP将通过“重新传输导致超时的段”并重新启动计时器来做出响应<br>3.接收到有效的确认段：TCP将ACK的y值与其sendBase（最早的未确认字节的序列号）进行比较。如果“ y&gt;sendBase”，则ACK确认一个或多个先前未确认的段（累积确认）。如果还有尚未确认的段，则更新<code>sendBase</code>变量并重新启动计时器。<br>这里不是很理解……</p></blockquote><h3 id="3-5-5-Flow-Control"><a href="#3-5-5-Flow-Control" class="headerlink" title="3.5.5 Flow Control"></a>3.5.5 Flow Control</h3><p>receiver controls sender, so sender won’t overflow receiver’s buffer by transmitting too much, too fast.</p><ul><li>receiver “advertises” free buffer space by including rwnd value in TCP header of receiver-to-sender segments<ul><li>RcvBuffer size set via socket options (typical default is 4096 bytes)</li><li>many operating systems autoadjust RcvBuffer</li></ul></li><li>sender limits amount of unacked (“in-flight”) data to receiver’s rwnd value </li><li>guarantees receive buffer will not overflow</li></ul><blockquote><p>流量控制和拥塞控制不一样,前者防止接收方溢出，仅由两个端点驱动，后者防止网络拥塞。</p></blockquote><h3 id="3-5-6-TCP-Connection-Management"><a href="#3-5-6-TCP-Connection-Management" class="headerlink" title="3.5.6 TCP Connection Management"></a>3.5.6 TCP Connection Management</h3><ol><li>The client-side TCP sends a special TCP segment to server-side TCP. This segment <strong>doesn’t contain any application-layer data</strong> but the <strong>flag bit SYN is set to 1</strong>. The segment is referred to as a <em>SYN segment</em>. The client also <strong>randomly chooses an initial sequence number</strong> (<code>client_isn</code>) and <strong>puts this number in the sequence number field of the initial TCP SYN segment</strong>. (randomizing <code>client_isn</code> is interesting to avoid security attacks).<ol><li>The TCP SYN segment arrives at the server-side, it is extracted from the datagram. The server allocates the TCP buffers and variables to the connection and <strong>sends a connection-granted segment to the client</strong>. This segment also contains no application-layer data. The <strong>SYN flag is set to 1</strong>, the <strong>ACK field in the header is set to <code>client_isn+1</code></strong>. <strong>The server chooses its own initial sequence number <code>server_isn</code></strong> and <strong>puts this value in the sequence number field of the TCP segment header</strong>. This segment is referred to as <em>SYNACK segment</em>.</li><li>Upon receiving the SYNACK segment, the client also allocates buffers and variables to the connection. The client then <strong>sends the server yet another segment which acknowledges the SYNACK</strong> (<code>server_isn+1</code> is set the acknowledgement field of the TCP segment header)<blockquote><p>TCP的三次握手</p></blockquote></li></ol></li></ol><h2 id="3-6-Principles-of-Congestion-Control"><a href="#3-6-Principles-of-Congestion-Control" class="headerlink" title="3.6 Principles of Congestion Control"></a>3.6 Principles of Congestion Control</h2><h3 id="3-6-1-The-Causes-and-the-Costs-of-Congestion"><a href="#3-6-1-The-Causes-and-the-Costs-of-Congestion" class="headerlink" title="3.6.1 The Causes and the Costs of Congestion"></a>3.6.1 The Causes and the Costs of Congestion</h3><blockquote><p>原理不仔细看了，直接看TCP的拥堵控制</p></blockquote><h2 id="3-7-TCP-Congestion-Control"><a href="#3-7-TCP-Congestion-Control" class="headerlink" title="3.7 TCP Congestion Control"></a>3.7 TCP Congestion Control</h2><blockquote><p>这里只记录TCP拥堵控制中最重要的算法部分</p><h3 id="TCP-Congestion-Control-Algorithm"><a href="#TCP-Congestion-Control-Algorithm" class="headerlink" title="TCP Congestion-Control Algorithm"></a>TCP Congestion-Control Algorithm</h3><p>Three components :</p></blockquote><h4 id="1-Slow-Start"><a href="#1-Slow-Start" class="headerlink" title="1 - Slow Start"></a>1 - Slow Start</h4><p>When a TCP connection begins, <code>cwnd</code> is usually initialized to a small value of 1 MSS and only one segment is sent. <strong>Each acknowledged packet</strong> will cause the <code>cwnd</code> to be increased by 1 MSS and the sender will send now two segments (because the window is increased by one for each ack).<br>Therefore the number of segments doubles at each RTT, therefore the sending rate also doubles every RTT. Thus TCP send rate <strong>starts slow but grows exponentially during the slow start phase</strong>.<br>When does the growth end?</p><ul><li>Timeout: <code>cwnd</code> is set to 1 MSS and the slow start is started anew. Also the variable slow start threshold is initialized:<br><code>ssthresh = cwnd / 2 - (half of value of cwnd when congestion is detected)</code></li><li>When <code>cwnd &gt;= ssthresh</code> slow starts is stopped -&gt; congestion avoidance state</li><li>Three duplicate ACKs: fast retransmit and fast recovery state</li></ul><h4 id="2-Congestion-Avoidance"><a href="#2-Congestion-Avoidance" class="headerlink" title="2 - Congestion Avoidance"></a>2 - Congestion Avoidance</h4><p>TCP suppose congestion is present, how to adapt?<br>Instead of doubling <code>cwnd</code> every RTT, <code>cwnd</code> is increased <strong>by just a single MSS every RTT</strong>.<br>When should this linear increase stop?</p><ul><li>Timeout: <code>cwnd</code> is set to 1 MSS, and <code>ssthresh = cwnd (when loss happened) / 2</code></li><li>Three duplicate ACKs: <code>cwnd = (cwnd / 2) + 3 MSS</code> and <code>ssthresh = cwnd (when 3 ACKs received) / 2</code> -&gt; fast recovery state</li></ul><h4 id="3-Fast-Recovery"><a href="#3-Fast-Recovery" class="headerlink" title="3 - Fast Recovery"></a>3 - Fast Recovery</h4><p><code>cwnd</code> is increased by 1 MSS for every duplicate ACK received for the missing state that caused TCP to enter this state. When the ACK arrives for the missing segment, TCP goes into Congestion Avoidance after reducing <code>cwnd</code>.<br>If a timeout occurs <code>cwnd</code> is set to 1 MSS and <code>ssthresh</code> is set to half the value of <code>cwnd</code> when the loss event occurred.<br>Fast recovery is recommended but not required in TCP, in fact only the newer version of TCP, <strong>TCP Reno</strong> incorporated fast recovery.</p><h1 id="Chapter-4-The-Network-Layer-Data-Plane"><a href="#Chapter-4-The-Network-Layer-Data-Plane" class="headerlink" title="Chapter 4: The Network Layer:Data Plane"></a>Chapter 4: The Network Layer:Data Plane</h1><h2 id="4-1-Introduction"><a href="#4-1-Introduction" class="headerlink" title="4.1 Introduction"></a>4.1 Introduction</h2><blockquote><p>路由器的主要作用是将数据报从输入链接转发到输出链接。路由器既不运行，也不运行应用程序层或传输层，它们只运行到网络层</p></blockquote><h3 id="4-1-1-Forwarding-and-Routing"><a href="#4-1-1-Forwarding-and-Routing" class="headerlink" title="4.1.1 Forwarding and Routing"></a>4.1.1 Forwarding and Routing</h3><p>The role of the network layer is deceptively simple: <strong>to move packets from a sending hosts to a receiving host</strong>. To do so it performs two important functions:</p><ul><li><strong><em>Forwarding</em></strong>: When a packet arrives to a router’s input link, the router must move the packet to the appropriate output link. It is an action <strong>local</strong> to the router</li><li><strong><em>Routing</em></strong>: The network layer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are referred to as <strong>routing algorithsm</strong>. It is a <strong>network-wide</strong> action</li></ul><blockquote><p>每个路由器都有一个“转发表”。当路由器接收到数据包时，它将从标头中的特定字段中提取一个值，并在转发表中搜索该值。</p></blockquote><ul><li>Packet-switches: performs forwarding according to the value in a field in the header of the packet. Some packet switches called <strong>link-layer switches</strong> base their forwarding decisions on values in the fields of the <em>link-layer frame</em> (link-layer devices)<ul><li>Routers: base forwarding decisions on the value in the network-layer field. (network-layer devices) but also must implement link layer (no 3 without 2)</li></ul></li></ul><h4 id="Connection-Setup"><a href="#Connection-Setup" class="headerlink" title="Connection Setup"></a>Connection Setup</h4><p>in some computer networks there is a third really important networks-layer function: <strong>connection setup</strong>: a <strong>path-wide</strong> process that sets up connection state in routers.</p><h3 id="4-1-2-Network-Service-Models"><a href="#4-1-2-Network-Service-Models" class="headerlink" title="4.1.2 Network Service Models"></a>4.1.2 Network Service Models</h3><ol><li>Sending side:<ul><li><em>Guaranteed delivery</em></li><li><em>Guaranteed delivery with bounded delay</em></li></ul></li><li>Flow and receiving side:<ul><li><em>In-order packet delivery</em></li><li><em>Guaranteed minimal bandwidth</em></li><li><em>Guaranteed maximum jitter</em> (amount of time between transmission of two successive packets at the sender side is equal to the amount of time between their receipt at the destination, or that this spacing changes by no more than some specified value)</li><li><em>Security services</em>: encryption for confidentiality, data integrity and source authentication</li></ul></li></ol><blockquote><p><strong>互联网的网络层不提供以下任何一项</strong>：它提供的是“尽力而为”服务，没有时间或带宽保证，没有丢失或订单保证以及拥塞控制指示。</p></blockquote><h2 id="4-2-Virtual-Circuit-and-Datagrams-Networks"><a href="#4-2-Virtual-Circuit-and-Datagrams-Networks" class="headerlink" title="4.2 Virtual  Circuit and Datagrams Networks"></a>4.2 Virtual  Circuit and Datagrams Networks</h2><h3 id="4-2-1-Virtual-Circuit-Networks"><a href="#4-2-1-Virtual-Circuit-Networks" class="headerlink" title="4.2.1 Virtual-Circuit Networks"></a>4.2.1 Virtual-Circuit Networks</h3><p>The Internet is a datagram network but many alternative network architectures (ATM) are virtual-circuit networks. The connections in VC are called <em>*virtual circuits (VCs)3</em>.<br>A VC consists of</p><ol><li>A source-to-destination <em>path</em></li><li>VC numbers, one for each link along the path</li><li>Entries in the forwarding table in each router along the path</li></ol><h3 id="4-2-2-Datagram-Networks"><a href="#4-2-2-Datagram-Networks" class="headerlink" title="4.2.2 Datagram Networks"></a>4.2.2 Datagram Networks</h3><p>Each time an end system wants to send a packet, it sampts the packet with the address of the destination end system and pops the packet into the network. The routers along the path will use this address to forward it.<br>The router has a forward table that <em>maps destination addresses to link interfaces</em>. When a packet arrives, it reads the destination address, uses the table to determine what link to use, and forwards the packet to that output link interface.</p><blockquote><p>如果考虑使用IPv4，则地址长度为32位。为了避免表包含2 ^ 32个条目，路由器使用<strong>前缀</strong>。当一个地址有多个数学运算时，路由器将使用“最长前缀匹配规则” **。</p></blockquote><h2 id="4-3-What’s-Inside-a-Router"><a href="#4-3-What’s-Inside-a-Router" class="headerlink" title="4.3 What’s Inside a Router?"></a>4.3 What’s Inside a Router?</h2><ul><li><em>Input ports</em>: performs the physical layer functions of incoming link at the router. It is also here that the forwarding table is consulted to determine the output port to which the arriving packet will be forwarded via the switching fabric. Control packets (protocol info) are forwarded to the routing processor.</li><li><em>Switching fabric</em>: connects input prots to output ports.</li><li><em>Output ports</em>: stores packets received from the switching fabric and performs the necessary link layer and physical layer functions.</li><li><em>Routing processor</em>: executes the routing protocols (algorithms), maintains routing tables and attached link state information and computes the forwarding table for the router.<h3 id="4-3-1-Input-Processing"><a href="#4-3-1-Input-Processing" class="headerlink" title="4.3.1 Input Processing"></a>4.3.1 Input Processing</h3><ul><li>physical and link layer processing</li></ul></li><li>chekcing the packet’s version number, checksum, time to live….</li><li>updating counters for network management.</li></ul><h3 id="4-3-2-Switching"><a href="#4-3-2-Switching" class="headerlink" title="4.3.2 Switching"></a>4.3.2 Switching</h3><p>Can be performed in different ways:</p><h4 id="Switching-via-memory"><a href="#Switching-via-memory" class="headerlink" title="Switching via memory"></a>Switching via memory</h4><blockquote><p>在CPU和输入输出端口的控制下进行的切换在传统操作系统中充当传统I / O设备。数据包到达后，复制到处理器内存中，处理器确定输出端口，然后将数据包复制到输出端口的缓冲区。<br>无并行转发（仅1个内存读/写总线）</p></blockquote><h4 id="Switching-via-a-bus"><a href="#Switching-via-a-bus" class="headerlink" title="Switching via a bus"></a>Switching via a bus</h4><blockquote><p>输入端口通过共享总线将数据包直接传输到输出端口，而无需路由处理器的干预。输入端口将内部标头添加到数据包中。所有输出端口都接收到数据包，但是只有与内部标头中的标签匹配的端口才会保留该数据包。输出端口将删除此内部接头连接器。交换速度仅限于总线速度，因为一次只有一个数据包可以穿越总线（必须等待多个到达的数据包）。</p></blockquote><h4 id="Switching-via-an-interconnected-network"><a href="#Switching-via-an-interconnected-network" class="headerlink" title="Switching via an interconnected network"></a>Switching via an interconnected network</h4><h2 id="4-4-The-Internet-Protocol-IP-Forwarding-and-Addressing-in-the-Internet"><a href="#4-4-The-Internet-Protocol-IP-Forwarding-and-Addressing-in-the-Internet" class="headerlink" title="4.4 The Internet Protocol (IP): Forwarding and Addressing in the Internet"></a>4.4 The Internet Protocol (IP): Forwarding and Addressing in the Internet</h2><p>We know move to study of the network layer in the Internet. There are two versions of the IP (Internet Protocol) in use today: IPv4 and IPv6.<br>There 3 main components in the Internet: the IP Protocol (addressing, datagram format and packet handling conventions), the routing protocol (path selection), the Internet Control Message Protocol (ICMP) (error reporting and network information).</p><h3 id="4-4-1-Datagram-Format"><a href="#4-4-1-Datagram-Format" class="headerlink" title="4.4.1 Datagram Format"></a>4.4.1 Datagram Format</h3><p>Some fields:</p><ul><li><em>Version number</em>: 4 bits specifying the IP protocol version of the datagram (IPv4 or IPv6 )</li><li><em>Header length</em>: the length of the packet is variable therefore this field tells where the header ends and the data begins. Usually datagrams contain no option so that the typical IP datagram has <strong>20-byte header</strong></li><li><em>Type of service</em> (TOS): allows different types of datagrams to be distinguished from each other. (eg real time vs non real time)</li><li><em>Datagram length</em>: 16 bits specifying the total length, that is header + data measured in bytes. 16 bits -&gt; max header length = 65535 bytes, but usually datagrams are rarely larger than 1500 bytes.</li><li><em>Identifier, flags, fragmentation offset</em>: used for IP fragmentation. (NB: IPv6 doesn’t allow fragmentation at routers)</li><li><em>Time-to-live</em> (TTL): used to avoid that datagrams circulate forever. It is decreased by one each time the datagram is processed by a router. When TTL = 0, the datagram is dropped</li><li><em>Protocol</em>: only used when datagram reaches its final destination, it specifies what <em>transport protocol</em> to which the data of the datagram should be passed. EX: 6 -&gt; TCP, 17 -&gt; UDP</li><li><em>Header checksum</em>: helps the router to detect bit errors in a received IP datagram. Computation: each two bytes in the <strong>header</strong> are considered as numbers, summed up using the 1s complement arithmetic. The 1s complement of this sum is then put in the checksum field. A router computes the checksum for each datagram. If the computed one doesn’t equal the one in the field then the router has detected an error. Usually the datagram is discarded. As it is recomputed at each router, it may change.</li><li><em>Source and destination IP addresses</em></li><li><em>Options</em>: rarely used, dropped by IPv6</li><li><em>Data (payload)</em>: usually contains the transport layer segment but can also contain ICMP messages</li></ul><blockquote><p>IP 报文格式如上</p></blockquote><h4 id="IP-Datagram-Fragmentation"><a href="#IP-Datagram-Fragmentation" class="headerlink" title="IP Datagram Fragmentation"></a>IP Datagram Fragmentation</h4><p>In IPv4, to comply with fragmentation, the header contains the fields:</p><ul><li><em>Identifiers</em>: identifies the <strong>unfragmented datagram</strong> (same for all fragments)</li><li><em>flags</em>: in particular there is one flag set to 0 if the fragment is the last or to 1 if there are more to come</li><li><em>fragmentation offset</em>: an integer x, the data in the fragment should be inserted beginning at byte x * 8</li></ul><blockquote><p>如果一个片段包含错误或丢失，则所有其他片段都将被丢弃，TCP将使发送方重新传输所有数据。<br>碎片会使网络和终端系统复杂化，可用于致命的DoS攻击，例如Jolt2攻击</p></blockquote><h3 id="4-4-2-IPv4-Addressing"><a href="#4-4-2-IPv4-Addressing" class="headerlink" title="4.4.2 IPv4 Addressing"></a>4.4.2 IPv4 Addressing</h3><p>IPv4 addresses are 32 bits long (4 bytes) -&gt; max 2^32 possible addresses. They are typically writen in <strong>dotted decimal notation</strong> where each byte of the address is written in deciaml from and separated by a period from the others.<br>EX 193.32.216.9 === 11000001 00100000 11011000 00001001<br>Each interface on every host (except host behind NATs) must have a unique IP address. How are these computed?<br>A portion is determined by the subnet to which the host is connected.</p><blockquote><p>子网是网络互连的最终系统和一个路由器的一部分。 （也称为<em> IP网络</em>或<em>网络</em>）。 IP将地址分配给子网x.x.x.x / y，其中/ y表示法（有时称为“子网掩码”）表示<em> 32位数量的最左边的y位定义了子网地址</em>。如果y为24，则<em>将</em>要求*连接到a.a.a.0 / 24子网的主机具有a.a.a.xxx格式的地址。</p></blockquote><p>The Internet’s address assignment strategy is known as <strong>Classless Interdomain Routing (CIDR)</strong>. It generalizes the notion of subnet addressing. Consider a.b.c.d/x : the x most significant bits constitute the network portion of the IP address and are often referred to as the <strong>prefix</strong> (or <em>network prefix</em>). EX an organization is assigned a block of contiguous addresses, that is, a range of addresses with a common prefix.</p><h4 id="Obtaining-a-Block-of-Addresses"><a href="#Obtaining-a-Block-of-Addresses" class="headerlink" title="Obtaining a Block of Addresses"></a>Obtaining a Block of Addresses</h4><p>A network administrator contacts an ISP which would provide a partition of the addresses that had already been allocated to him.<br>EX ISP has 200.23.16.0/20, it splits in 8 equal sized blocks: 200.23.16.0/23, 200.23.18.0/23, 200.23.20.0/23, …, 200.23.30.0/23</p><h4 id="Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol"><a href="#Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol" class="headerlink" title="Obtaining a Host Address: The Dynamic Host Configuration Protocol"></a>Obtaining a Host Address: The Dynamic Host Configuration Protocol</h4><p>Once an organization has obtained a block of addresses, it can assign individual IP addresses to the hosts and router interfaces which are part of it. This can be done either <strong>manually</strong> (by the network administrator) or automatically by the <strong>Dynamic Host Configuration Protocol (DHCP)</strong>.<br>It can be configured so that a host receives the same IP each time it connects to the network or a temporary IP addresses that will change upon each connection. DHCP also transmits to hosts additional information (subnet mask, address of first-hop = default gateway, address of local DNS server).</p><p>For a new client there is a 4 step process i nthe DHCP protcol:</p><ol><li><em>DHCP server discovery</em> c (client) looks for a server sending <strong>DHCP discover message</strong> a UDP packet directed to port 67. This segment is encapsulated in datagram sent to 255.255.255.255 (broadcast address) from address 0.0.0.0</li><li><em>DHCP server offer(s)</em> s (server) replies with a <strong>DHCP offer message</strong> broadcast to all nodes on the subnet using (sent to 255.255.255.0). c may receiver many of these (more servers) containing the transaction ID, proposed IP address and an address lease time (amout of time for which the address will be valid)</li><li><em>DHCP request</em>: c chooses one offer and responds to s with a <strong>DHCP request message</strong> echoing back the configuration parameters</li><li><em>DHCP ACK</em> s responds with <strong>DHCP ACK message</strong> confirming</li></ol><blockquote><p>DHCP是一个“客户端-服务器协议”，客户端是一个需要网络配置信息的新到达主机，服务器是一个路由器或一个“ DHCP中继代理”，它们知道该网络的DHCP服务器的地址。</p></blockquote><h4 id="Network-Address-Translation-NAT"><a href="#Network-Address-Translation-NAT" class="headerlink" title="Network Address Translation (NAT)"></a>Network Address Translation (NAT)</h4><p>Problems with NAT:</p><ul><li>Port number should be used for addressingi processes not hosts</li><li>Routers shouldn’t have access to the transport layer (ports)</li><li>NAT violates end-to-end argument (any host should be able to contact any other host)</li><li>NAT interferes with P2P applications (peers hidden by NAT), therefore the need of <strong>connection reversal</strong> for <strong>NAT traversal</strong></li></ul><blockquote><p>启用NAT的路由器定义了一个“领域”（或专用网络）（其地址仅对该网络中的设备有意义的网络），并且它可以将整个32位地址空间用于与其连接的设备，它还将具有用于与外部通信的公共地址。图片是说明性的。</p></blockquote><h3 id="4-4-3-Internet-Control-Message-Protocol"><a href="#4-4-3-Internet-Control-Message-Protocol" class="headerlink" title="4.4.3 Internet Control Message Protocol"></a>4.4.3 Internet Control Message Protocol</h3><p>ICMP is considered part of IP but architecturally lies just above IP as ICMP messages are carried inside IP datagrams as payloads.<br>ICMP have a type and a code field and carry the header and the first 8 bytes of the datagram that caused the message to be generated in the first place.<br>Ping and traceroute are implemented using ICMP messages</p><blockquote><p>ICMP用于在主机和路由器之间传递网络层信息，通常用于错误报告（例如，目标网络不可达）。</p></blockquote><h3 id="4-4-4-IPv6"><a href="#4-4-4-IPv6" class="headerlink" title="4.4.4 IPv6"></a>4.4.4 IPv6</h3><h4 id="Datagram-format"><a href="#Datagram-format" class="headerlink" title="Datagram format"></a>Datagram format</h4><ul><li>A number of IPv4 fields have been dropped or made optional resulting in a <strong>40-byte fixed-length header</strong> which allows faster datagram processing.<ul><li><em>Flow label</em> not clear definition. 20-bit</li><li><em>Version</em>: 4-bit for IPv6 or 4. If ipv6 -&gt; 0110</li><li><em>Traffic class</em>: 8 bit similar to TOS</li><li><em>Payload length</em>: 16 bit unsigned integer indicating number of bytes following the 40-byte datagram header</li><li><em>Next header</em>: transport layer protocol</li><li><em>Hop limit</em>: decremented by one by each router forwarding the datagram, when 0, the datagram is discarded</li></ul></li></ul><h4 id="Transitioning-from-IPv4-to-IPv6"><a href="#Transitioning-from-IPv4-to-IPv6" class="headerlink" title="Transitioning from IPv4 to IPv6"></a>Transitioning from IPv4 to IPv6</h4><p>IPv6 is back compatible with IPv4 but not viceversa.</p><p>It’s not humanable possible to decide a date on which all machines would change their protocol.<br>The most straightfoward way is a <strong>dual stack</strong> approach where IPv6 nodes also have a complete IPv4 implementation. To determine whether anotehr node is IPv6 or IPv4-only DNS can be used, just checking whether the node has a IPv6 address or an IPv4 one. However this will bring about the loss of data in specific IPv6 header fields.</p><blockquote><p>另一种方法是“隧道连接”：当两个IPv6节点通过中间的IPv4路由器连接时，我们将IPv4节点称为“隧道”，整个IPv6数据报将放入要传播的IPv4数据报的有效负载字段中隧道不知道详细信息，而是由能够提取IPv6数据报并进行路由的目标IPv6节点接收到的。</p></blockquote><h1 id="Chapter-5-The-Network-Layer-Control-Plane"><a href="#Chapter-5-The-Network-Layer-Control-Plane" class="headerlink" title="Chapter 5: The Network Layer:Control Plane"></a>Chapter 5: The Network Layer:Control Plane</h1><h1 id="5-2-Routing-Algorithms"><a href="#5-2-Routing-Algorithms" class="headerlink" title="5.2 Routing Algorithms"></a>5.2 Routing Algorithms</h1><ul><li><strong>Global routing algorithms</strong>: compute the least-cost path between a source and a destination using complete, global knowledge about the network.<br>They are often referred to as <strong>link-state (LS) algorithms</strong> since the algorithm must be aware of the cost of each link in the network<ul><li><strong>Decentralized routing algorthms</strong>: compute the least-cost path in an iterative, distributed manner: no node has complete information about the cost of all network links. Instead, each node begins with only the knowledge of the costs of its own directly attached links.</li></ul></li></ul><h3 id="5-2-1-The-Link-State-LS-Routing-Algorithm"><a href="#5-2-1-The-Link-State-LS-Routing-Algorithm" class="headerlink" title="5.2.1 The Link-State (LS) Routing Algorithm"></a>5.2.1 The Link-State (LS) Routing Algorithm</h3><p><strong>all nodes having an identical and complete view of the network</strong> (each node could run the algorithm).<br>A link-state algorithm can be <strong><em>Dijkstra’s algorithm</em></strong> or <strong><em>Prim’s algorithm</em></strong>.</p><h3 id="5-2-2-The-Distance-Vector-DV-Routing-Algorithm"><a href="#5-2-2-The-Distance-Vector-DV-Routing-Algorithm" class="headerlink" title="5.2.2 The Distance-Vector (DV) Routing Algorithm"></a>5.2.2 The Distance-Vector (DV) Routing Algorithm</h3><p>The <strong>distance-vector</strong> algorithm is <strong>iterative</strong>, <strong>asynchronous</strong> and <strong>distributed</strong>.</p><ul><li><em>Distributed</em> because each node receives some information from one or more of its directly attached neighbors, performs a calculation and then distributes the results back to its neighbors.</li><li><em>iterative</em>: the process continues on until no more information is exchanged between neighbors (self terminating)</li><li><em>asynchronous</em>: the nodes are not required to operate in lockstep with each other</li></ul><p>The least cost between x and y d(x,y) can be determined using the <strong><em>Bellman-Ford</em></strong> equation :</p><script type="math/tex; mode=display">d(x,y) = min_v {c(x,y) + d(v,y)}</script><h3 id="5-2-3-Hierarchical-Routing"><a href="#5-2-3-Hierarchical-Routing" class="headerlink" title="5.2.3 Hierarchical Routing"></a>5.2.3 Hierarchical Routing</h3><p>In practice it is not possible to have a network of interconnected routers running the same routing algorithm because of two reasons:</p><ul><li><em>Scale</em> if the number of routers is large, running LS or DV algorithms for the whole network becomes prohibitive for memory, processing, storing and timing costs.</li><li><em>Administrative autonomoy</em> an organization should be able to organize its network as it wishes, while still being able to connect its network to the outside world.</li></ul><h2 id="5-2-Routing-in-the-Internet"><a href="#5-2-Routing-in-the-Internet" class="headerlink" title="5.2 Routing in the Internet"></a>5.2 Routing in the Internet</h2><h3 id="5-2-1-Intra-AS-Routing-in-the-Internet-RIP"><a href="#5-2-1-Intra-AS-Routing-in-the-Internet-RIP" class="headerlink" title="5.2.1 Intra-AS Routing in the Internet: RIP"></a>5.2.1 Intra-AS Routing in the Internet: RIP</h3><p>Intra-AS routing protocols are also known as <strong>interior gateway protocols</strong>. Historically two of these have been used extensively in the Internet: <strong>Routing Information Protocol (RIP)</strong> and <strong>Open Shortest Path First (OSPF)</strong>.</p><h3 id="5-2-2-Intra-AS-Routing-in-the-Internet-OSPF"><a href="#5-2-2-Intra-AS-Routing-in-the-Internet-OSPF" class="headerlink" title="5.2.2 Intra-AS Routing in the Internet: OSPF"></a>5.2.2 Intra-AS Routing in the Internet: OSPF</h3><p>OSPF and the related IS-IS are typically deployed in upper-tier ISPs whereas RIP is deployed in lower-tier ISPs and enterprise networks. Open indicates that the routing protocol speficication is publicly available.</p><blockquote><p>路由器向AS中的所有其他路由器广播路由信息，而不仅仅是邻居。每当链接状态发生变化时，或者每30分钟（如果链接状态没有变化），都会进行广播。 OSPF通告包含在IP承载的OSPF消息中，该协议的上层协议为89，因此OSPF必须实现可靠的消息传输和链接状态广播。 OSP还使用HELLO消息检查所连接邻居的链接是否正常。</p></blockquote><p>OSPF offers some services:</p><ul><li><em>security</em>: OSPF messages can be authenticated (not active by default).</li><li><em>multiple same-cost paths</em>: two paths having same cost can be used at the same time.</li><li><em>integrated support for unicast and multicast routing</em></li><li><em>support for hierarchy within a single routing domain</em>: ability to structure an autonomous system hierarchically. A OSPF AS can be configured hierarchically into areas, each running its own OSPF algorithm, with each router broadcasting its link state to all other routers in that area. <strong>Area border routers</strong> are responsible for routing packets outside the area and one area is configured to be the <strong>backbone area</strong>, which routes traffic between other areas in the AS, it contains area border routers but also normal routers.</li></ul><h3 id="5-4-Inter-AS-Routing-BGP"><a href="#5-4-Inter-AS-Routing-BGP" class="headerlink" title="5.4 Inter-AS Routing: BGP"></a>5.4 Inter-AS Routing: BGP</h3><p>The <strong>Border Gateway Protocol (BGP)</strong> is the de facto standard inter-AS routing protocol in today’s Internet. It provides each AS means to:</p><ul><li>obtain reachability information from neighboring ASs</li><li>propagate reachability information to all internal routers</li><li>determine good routes to subnets using reachability information and AS policy.</li><li>it allows <strong>each subnet to advertise its existence to the rest of the Internet</strong></li></ul><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><p>For each connection, the two routers at the end of it are called <strong>BGP peers</strong> and the connection is called a <strong>BGP session</strong>. A session spanning two ASs is an <strong>external BGP (eBGP) session</strong> and BGP sessions between routers within an AS is called an <strong>internal BGP (iBGP) session</strong>. Destinations are not hosts, but CIDRized <strong>prefixes</strong>, each representing a subnet or collection of subnets.</p><blockquote><p>这是一个非常复杂的算法。路由器使用端口179通过半永久性TCP连接交换信息。通常，每个链路都有一个这样的BGP TCP连接，直接连接两个不同AS中的两个路由器，但是同一AS中的路由器之间也存在半永久性TCP连接。</p></blockquote><h4 id="Path-Attributes-and-BGP-Routes"><a href="#Path-Attributes-and-BGP-Routes" class="headerlink" title="Path Attributes and BGP Routes"></a>Path Attributes and BGP Routes</h4><p>In BGP an AS is identified by its <strong>globally unique AS number (ASN)</strong> which is assigned by ICANN regional registries. When a router advertises a prefix across a BGP session, it includes with the prefix a number of <strong>BGP attributes</strong>, a prefix with its attributes is called a <strong>route</strong>. Two other important attributes are:</p><ul><li><em>AS-PATH</em>: contains the ASs through which the advertisement for the prefix has passed. When a prefix is passed into an AS, the AS adds its ASN to the AS-PATH.<br>This attribute is used to detect and prevent looping advertisements (if router sees that its AS is already in AS-PATH, it rejects the ad) and to choose among multiple paths to the same prefix.<br>-<em>NEXT-HOP</em>: <strong>the router interface that begins the AS-PATH</strong>.</li></ul><blockquote><p>BGP还包括一些属性，这些属性允许路由器为路由分配首选项度量标准，并指示如何在源头将前缀插入BGP。<br>当路由器收到路由通告时，它将使用其“导入策略”来决定是否接受或过滤路由以及是否设置某些属性，例如路由器优先级指标。</p></blockquote><h4 id="BGP-Route-Selection"><a href="#BGP-Route-Selection" class="headerlink" title="BGP Route Selection"></a>BGP Route Selection</h4><p>The input of the selection is the set of all routes that have been learned and accepted by the router. If two or more routes exist for the same prefix, elimination rules are applied until only one remains.</p><h1 id="Chapter-6-The-Link-Layer-Links-Access-Networks-and-LANs"><a href="#Chapter-6-The-Link-Layer-Links-Access-Networks-and-LANs" class="headerlink" title="Chapter 6: The Link Layer: Links, Access Networks and LANs"></a>Chapter 6: The Link Layer: Links, Access Networks and LANs</h1><h2 id="6-1-Introduction-to-the-Link-Layer"><a href="#6-1-Introduction-to-the-Link-Layer" class="headerlink" title="6.1 Introduction to the Link Layer"></a>6.1 Introduction to the Link Layer</h2><h3 id="6-1-1-The-Services-Provided-by-The-Link-Layer"><a href="#6-1-1-The-Services-Provided-by-The-Link-Layer" class="headerlink" title="6.1.1 The Services Provided by The Link Layer"></a>6.1.1 The Services Provided by The Link Layer</h3><p>Possible services offered by a link-layer protocol include:</p><ul><li><em>Framing</em>: all link layer protocols encapsulate each network layer datagram  within a link-layer frame before transmission. A frame consists of a data field, containing the datagram, and a number of header fields, whose structure is determined by the protocol.</li><li><em>Link access</em>: A <strong>Medium Access Control</strong> (MAC) protocol specifies the rules by which a frame is transmitted onto the link.</li><li><em>Reliable delivery</em>: the protocol guarantees to move each datagram across the link without loss or errors. A reliable delivery protocol is often used for links highly prone to errors (WiFi) so that the error can be corrected locally, where it happens, rather than forcing an end-to-end retransmission. However it can represent a significant overhead for low bit-error links (cable) and therefore many wired link-layer protocols do not provide a reliable delivery service.</li><li><em>Error detection and correction</em>: signal attenuation and electromagnetic noise can introduce errors. Because there is no need to forward a datagram that has an error, may link-layer protocols provide a mechanism to detect such bit errors so that they can drop the frames. This can be accomplished transmitting error-detection bits in the frame. Link layer error detection is usually more sophisticated and <em>implemented in hardware</em>.</li></ul><h2 id="6-2-Error-Detection-and-Correction-Techniques"><a href="#6-2-Error-Detection-and-Correction-Techniques" class="headerlink" title="6.2 Error-Detection and -Correction Techniques"></a>6.2 Error-Detection and -Correction Techniques</h2><p>Error detection and correction allow the receiver to sometimes, <em>but not always</em>, detect that bit errors have occurred. Even with the use of error-detection bits, there still may be <strong>undetected bit errors</strong> (the receiver is unaware of the presence of corrupted bits).<br>We want to keep the probability of such an event small. Let’s now consider three techniques for detecting errors in the transmitted data: parity checks, checksumming methods and cyclic redundancy checks</p><h3 id="6-2-1-Parity-Checks"><a href="#6-2-1-Parity-Checks" class="headerlink" title="6.2.1 Parity Checks"></a>6.2.1 Parity Checks</h3><h3 id="6-2-2-Checksumming-Methods"><a href="#6-2-2-Checksumming-Methods" class="headerlink" title="6.2.2 Checksumming Methods"></a>6.2.2 Checksumming Methods</h3><h3 id="6-2-3-Cyclic-Redundancy-Check-CRC"><a href="#6-2-3-Cyclic-Redundancy-Check-CRC" class="headerlink" title="6.2.3 Cyclic Redundancy Check (CRC)"></a>6.2.3 Cyclic Redundancy Check (CRC)</h3><p><strong>Cyclic Redundancy Check (CRC) codes</strong> are also known as <strong>polynomial codes</strong> since it is possible to view the string to be sent as a polynomial whose coefficients are the 0 and 1 values in the bit string with operation interpreted as polynomial arithmetic.<br>Sender and receiver must agree on a <em>r+1</em> bit pattern know as <strong>generator</strong> which we’ll denote as <em>G</em>. We require the leftmost bit of G to be a 1. For a given piece of data <em>D</em> the sender will choose <em>r</em> additional bits, <em>R</em>, and append them to <em>D</em> such that the resulting <em>d + r</em> bit pattern, interpreted as a binary number, is exactly divisible by G using modulo-2 arithmetic.<br>Checking is therefore easy: the receiver divides the <em>d + r</em> received by bits by <em>G</em>, if the remainder is nonzero, an error has occurred, otherwise the data is accepted as being correct.<br>All CRC calculations are done in modulo 2 without carries in addition or borrows in subtraction (+ = - = xor).</p><h2 id="6-3-Multiple-Access-Links-and-Protocols"><a href="#6-3-Multiple-Access-Links-and-Protocols" class="headerlink" title="6.3 Multiple Access Links and Protocols"></a>6.3 Multiple Access Links and Protocols</h2><p>There are two types of network links: point-to-point and broadcast links. A <strong>point-to-point link</strong> consists of a single sender at one end of the link and a single receiver at the other end of the link. A <strong>broadcast link</strong> can have multiple sending and receiving nodes all connected to the same, single, shared broadcast channel. </p><blockquote><p>计算机网络具有“多种访问协议”，节点通过这些协议来调节它们向共享广播信道的传输。<br>超过两个节点可以同时发送帧，这将导致所有节点同时接收多个帧：所有接收器的<em>*碰撞帧。通常，在发生冲突的情况下，</em>任何接收节点都无法理解任何帧*，它们不可避免地纠缠在一起，因此“丢失”，在冲突期间浪费了信道。</p></blockquote><p>The <strong>multiple access problem</strong>: How to coordinate the access of multiple sending and receiving nodes to a shared broadcast channel?</p><h3 id="6-3-1-Channel-Partitioning-Protocols"><a href="#6-3-1-Channel-Partitioning-Protocols" class="headerlink" title="6.3.1 Channel Partitioning Protocols"></a>6.3.1 Channel Partitioning Protocols</h3><p>TDM and FDM (from circuit switching) are in this category.<br>A third channel partitioning tool is <strong>code division multiple access (CDMA)</strong> which assigns a different <em>code</em> to each node. Each node then uses its unique code to encode the data bits it sends. If the codes are chosen carefully, then all nodes can transmit simultaneously and yet have their respective receivers correctly receive a sender’s encoded data bits.</p><h3 id="6-3-2-Random-Access-Protocols"><a href="#6-3-2-Random-Access-Protocols" class="headerlink" title="6.3.2 Random Access Protocols"></a>6.3.2 Random Access Protocols</h3><h4 id="Slotted-ALOHA"><a href="#Slotted-ALOHA" class="headerlink" title="Slotted ALOHA"></a>Slotted ALOHA</h4><p>If <em>p</em> is a probability then the operation of slotted ALOHA in each node is simple:</p><ul><li>each node waits the beginning of the next slot to transmit the entire frame in a slot</li><li>If no collision occurs, the frame is considered delivered</li><li>If collision, this is detect before the end of the slot. The node retransmits its frame <em>in each subsequent slot</em> with probability <em>p</em> (probability of retransmission) until the frame is transmitted  without a collision.</li></ul><h4 id="Carrier-Sense-Multiple-Access-CSMA"><a href="#Carrier-Sense-Multiple-Access-CSMA" class="headerlink" title="Carrier Sense Multiple Access (CSMA)"></a>Carrier Sense Multiple Access (CSMA)</h4><p>CSMA and CSMA/CD (collision detection) embody two rules:</p><ul><li><strong>carrier sensing</strong>: if a node is transmitting, the others wait until they detect no transmission for a short amount of time and begin transmission.</li><li><strong>collision detection</strong>: a transmitting node listens to the channel while it’s transmitting, if it detects that another node is transmitting, it stops transmitting and waits for a random amount of time before repeating the sense-and-transmit-when-idle-cycle.</li></ul><blockquote><p>显然，信道的“传播延迟”起着至关重要的作用：时间越长，载波侦听节点仍无法感知已经开始的传输的机会就越大。</p></blockquote><h4 id="Carrier-Sense-Multiple-Access-with-Collision-Detection-CSMA-CD"><a href="#Carrier-Sense-Multiple-Access-with-Collision-Detection-CSMA-CD" class="headerlink" title="Carrier Sense Multiple Access with Collision Detection (CSMA/CD)"></a>Carrier Sense Multiple Access with Collision Detection (CSMA/CD)</h4><p>When a node detects a collision, it ceases transmission immediately in Collision Detection.<br>A link layer frame is prepared, if the node senses that the channel is idle (no energy is entering the adapter from the channel), it starts to transmit the frame, else it waits until it detects idle. While transmitting, the node monitors the channel for usage from other nodes, if the entire frame is transmitted without detecting usage, then the adapter is finished. If energy is detected from other adapters while transmitting, the node aborts transmission (stops), waits for  a random amount of time and then returns to checking for idle.</p><h4 id="CSMA-CD-Efficiency"><a href="#CSMA-CD-Efficiency" class="headerlink" title="CSMA/CD Efficiency"></a>CSMA/CD Efficiency</h4><p>Is the long run fraction of time during which frames are being transmitted without collision. If the propagation delay approaches 0, the efficiency approaches 1.<br>Also if the propagation delay becomes very large, efficiency approaches 1.</p><h3 id="6-3-3-Taking-Turns-Protocols"><a href="#6-3-3-Taking-Turns-Protocols" class="headerlink" title="6.3.3 Taking-Turns Protocols"></a>6.3.3 Taking-Turns Protocols</h3><p>There are a lot of them, we’ll cover two of the more important, the first one being the <strong>polling protocol</strong>. It requires one of the nodes to be designated as a master node which <strong>polls</strong> each of the nodes in a round-robin fashion.<br>The master tells node 1 that it can transmit up to some maximum number of frames, when node 1 is finished (the master checks for energy in the channel) the master tells the same to node 2 and so on.<br>The polling protocol eliminates the collisions and empty slots that plague random access protocols, resulting in a much higher efficiency.</p><p>The second protocol is the <strong>token-passing protocol</strong> in which there is no master method. A small, special purpose frame known as <strong>token</strong> is exchanged among the nodes in some fixed order. When a node receives a toke, it holds it only if it has some frames to transmit otherwise it immediately forwards it to the next node.If a node has frames to transmit when it receives the token, it sends up to a maximum number of frames and then passes the token.</p><h3 id="6-3-4-DOCSIS-The-Link-Layer-Protocol-for-Cable-Internet-Access"><a href="#6-3-4-DOCSIS-The-Link-Layer-Protocol-for-Cable-Internet-Access" class="headerlink" title="6.3.4 DOCSIS: The Link-Layer Protocol for Cable Internet Access"></a>6.3.4 DOCSIS: The Link-Layer Protocol for Cable Internet Access</h3><h2 id="6-4-Switched-Local-Area-Networks"><a href="#6-4-Switched-Local-Area-Networks" class="headerlink" title="6.4 Switched Local Area Networks"></a>6.4 Switched Local Area Networks</h2><h3 id="6-4-1-Link-Layer-Addressing-and-ARP"><a href="#6-4-1-Link-Layer-Addressing-and-ARP" class="headerlink" title="6.4.1 Link-Layer Addressing and ARP"></a>6.4.1 Link-Layer Addressing and ARP</h3><h4 id="MAC-Addresses"><a href="#MAC-Addresses" class="headerlink" title="MAC Addresses"></a>MAC Addresses</h4><p>A link-layer address is called <strong>LAN address</strong>, <strong>physical address</strong> or <strong>MAC address</strong>, the last name being the most popular. This address is <strong>6 bytes long</strong>, typically expressed in hexadecimal notation. They are supposed to be permanent but can be changed via software.<br><strong>No two adapters have the same address</strong>: the IEEE manages the MAC address space, usually assigning a 24 prefix to each manufacturer and letting him choose the content of the remaining 24 bits.<br>MAC address have a flat structure (no hierarchy such as in IP) and do not change.</p><blockquote><p>当适配器想要将帧发送到某个目标适配器时，它将目标适配器的MAC地址插入到帧中，然后将帧发送到LAN中。适配器可能会收到未寻址的帧，当发生这种情况时，适配器会检查帧的目标地址是否匹配其自身的地址，否则将丢弃该帧。当发送适配器要广播到整个网络时，它会在目标地址字段中插入一个特殊的“ MAC广播地址”，用于6个字节的地址，即FF-FF-FF-FF-FF-FF</p></blockquote><h4 id="Address-Resolution-Protocol-ARP"><a href="#Address-Resolution-Protocol-ARP" class="headerlink" title="Address Resolution Protocol (ARP)"></a>Address Resolution Protocol (ARP)</h4><p>The <strong>Address Resolution Protocol (ARP)</strong> translates network-layer addresses into link-layer addresses, analogously to DNS, but ARP resolves IP addresses only for hosts and router interfaces on the same subnet.<br>Each host and router has an <strong>ARP table</strong> which contain mappings of IP addresses to MAC addresses and a time-to-live TTL value which indicates when each mapping will be deleted from the table. A typical TTL is 20 minutes from when an entry is placed in the ARP table.<br>The table does not necessarily contain an entry for every host and router on the subnet.</p><blockquote><p>ARP查询和响应都具有相同的格式：发送将ARP请求转发到广播地址（目标地址），包含查询的帧将被子网中的所有其他适配器接收。每个适配器将帧传递给ARP模块，该模块检查其IP地址是否与查询中的目标IP地址匹配。匹配的人将响应与所需的映射一起发回。查询可以更新其表，并发送封装在链路层帧中的IP数据报。<br>ARP即插即用：表将自动建立。<br>ARP位于链路层和网络层之间的边界。</p></blockquote><h3 id="Sending-a-Datagram-off-the-Subnet"><a href="#Sending-a-Datagram-off-the-Subnet" class="headerlink" title="Sending a Datagram off the Subnet"></a>Sending a Datagram off the Subnet</h3><p>A datagram that has to be sent out of the subnet is first sent to the first-hop router on the path to the final destination (which is outside the subnet). How is its MAC acquired? Using ARP.<br>When the frame reaches the next-hop router of the destination subnet, it has to be moved inside, the router having to decide what interface to use. This is done using the forwarding table: the router extracts the datagram and checks the destination IP. The datagram is encapsulated again and sent into the subnet, this time the MAC address of the frame is indeed the destination MAC address of the ultimate destination, which the router acquire via ARP.</p><h3 id="6-4-2-Ethernet"><a href="#6-4-2-Ethernet" class="headerlink" title="6.4.2 Ethernet"></a>6.4.2 Ethernet</h3><h4 id="Ethernet-Frame-Structure"><a href="#Ethernet-Frame-Structure" class="headerlink" title="Ethernet Frame Structure"></a>Ethernet Frame Structure</h4><ul><li><em>Data fields</em> (46 to 1,500 bytes): carries the IP datagram (or other network-layer datagram). The MTU (maximum transmission unit) is 1500 bytes, compensated with fragmentation. The minimum is 46, is less, the data is “stuffed” and the receiving network layer uses the length field to eliminate the stuffing</li><li><em>Destination address</em> (6 bytes) destination MAC address.</li><li><em>Source address</em> (6 bytes)</li><li><em>Type field</em> (2 bytes) allows to multiplex network layer protocols (if not only IP is used, also ARP has its own type number 0x0806)</li><li><em>Cyclic redundant check (CRC)</em> (4 bytes): used for bit error detection</li><li><em>Preamble</em> (8 bytes): the first seven have value 10101010, the last has value 10101011. The first seven serve as “wake up” the receiving side and to <em>synchronize their clocks to that of the sender’s clock</em> the two 1s at the end of byte 8 alerts the receiver that the important stuff is about to come.</li></ul><blockquote><p>所有的以太网技术都向网络层提供“无连接服务”（无握手功能，类似于UDP）和“不可靠的服务”（向网络层提供服务）（无ACK，万一出现错误则掉线），这有助于使以太网变得简单而廉价。<br>如果由于丢弃了以太网帧而存在间隙，则应用程序是否会发现间隙的事实取决于所使用的传输层协议：不支持TCP（可靠的数据传输），可以支持UDP。</p></blockquote><h4 id="Ethernet-Technologies"><a href="#Ethernet-Technologies" class="headerlink" title="Ethernet Technologies"></a>Ethernet Technologies</h4><p>There are many variants and flavors of Ethernet which have been standardized over the years by the IEEE. They vary in speed: 10 Megabit, 100 Megabit, 1000 Megabit, 10 Gigabit…<br>They can also vary in the type of traffic they can transport….</p><h3 id="6-4-3-Link-Layer-Switches"><a href="#6-4-3-Link-Layer-Switches" class="headerlink" title="6.4.3 Link-Layer Switches"></a>6.4.3 Link-Layer Switches</h3><p>Switch receive and forward frames. They are <strong>transparent</strong>: adapters address each other, without knowing that the switch is sitting in the middle. As they’re output rate might be smaller than the input rate, they also have buffers to queue frames.</p><h3 id="Forwarding-and-Filtering"><a href="#Forwarding-and-Filtering" class="headerlink" title="Forwarding and Filtering"></a>Forwarding and Filtering</h3><p><strong>Filtering</strong> is the switch function that determines whether a frame should be forwarded to some interface or should just be dropped.<br><strong>Forwarding</strong> is the switch function that the determines the interfaces to which a frame should be directed and then moves the frame to those interfaces.<br>Switch filtering and forwarding are done with a <strong>switch table</strong> which contains entries for some (not necessarily all) of the hosts and routers on a LAN. Each entry contains:<br><code>(MAC address, interface leading toward that MAC, time at which the entry was placed in the table)</code></p><h4 id="Self-Learning"><a href="#Self-Learning" class="headerlink" title="Self-Learning"></a>Self-Learning</h4><p>The switch table is build <strong><em>automatically, dynamically and autonomously</em></strong> without any intervention from a network administrator: <strong>switches are self learning</strong>.</p><ol><li>The switch table is initially empty</li><li>For each incoming frame, the switch stores in its table<ol><li>the MAC address in the frame’s <em>source address field</em><ol><li>the interface from which the frame arrived</li><li>the current time</li></ol></li></ol></li><li>The switch deletes an address in the table if no frame are received with that address as the source after some period (<strong>aging time</strong>) so that to eliminate unused entries from the table</li></ol><blockquote><p>因此，开关是“即插即用设备”：它们无需人工干预。交换机也是全双工的，这意味着任何接口都可以同时发送和接收。</p></blockquote><h4 id="Properties-of-Link-Layer-Switching"><a href="#Properties-of-Link-Layer-Switching" class="headerlink" title="Properties of Link-Layer Switching"></a>Properties of Link-Layer Switching</h4><p>Advantages over buses or hubs:</p><ul><li><em>Elimination of collisions</em>: the switch buffers frames and never transmit more than one frame on a segment at any one time. The maximum aggregated throughput is the sum of all the switch interface rates</li><li><em>Heterogeneous links</em>: The switch providing isolation, different links can operate at different speeds and run over different media. Therefore switches are ideal for mixing legacy equipment with new equipment.</li><li><em>Management</em>: A switch can disconnect a malfunctioning adapter and a cut cable isolates only one host. Switches can gather statistics useful for debugging and planning the evolution of the network.</li></ul><h4 id="Switches-Versus-Routers"><a href="#Switches-Versus-Routers" class="headerlink" title="Switches Versus Routers"></a>Switches Versus Routers</h4><p>However to <strong>prevent the cycling of broadcast frames, the active topology of a swtiched network is restricted to a spanning tree</strong>. A large network requires large ARP tables in hosts and routers and would generate substantial ARP traffic and processing. Switches are also susceptible to broadcast storms: if one goes crazy and send an endless stream of broadcast frames, the others will forward all of the frames resulting in a network collapse.</p><blockquote><p>路由器的网络寻址是分层的，数据包通常不会循环，并且即使网络具有冗余路径，拓扑也不限于生成树。因此，数据包可以使用源和目标之间的最佳路径。但是路由器不是即插即用的（主机需要IP连接），并且每个数据包的处理时间通常比交换机更长。</p></blockquote><h1 id="Chapter-7-Wireless-and-Mobile-Networks"><a href="#Chapter-7-Wireless-and-Mobile-Networks" class="headerlink" title="Chapter 7: Wireless and Mobile Networks"></a>Chapter 7: Wireless and Mobile Networks</h1><h2 id="7-1-Introduction"><a href="#7-1-Introduction" class="headerlink" title="7.1 Introduction"></a>7.1 Introduction</h2><h2 id="7-2-Wireless-links-characteristics"><a href="#7-2-Wireless-links-characteristics" class="headerlink" title="7.2 Wireless links, characteristics"></a>7.2 Wireless links, characteristics</h2><p>important differences from wired link ….</p><ul><li>decreased signal strength: radio signal attenuates as it propagates through matter (path loss)</li><li>interference from other sources: standardized wireless network frequencies (e.g., 2.4 GHz) shared by other devices (e.g., phone); devices (motors) interfere as well</li><li>multipath propagation: radio signal reflects off objects ground, arriving ad destination at slightly different times</li></ul><p>It makes communication across (even a point to point) wireless link much more “difficult” </p><p>-SNR: signal-to-noise ratio</p><pre><code>- larger SNR – easier to extract signal from noise (a “good thing”)</code></pre><ul><li>SNR versus BER tradeoffs<ul><li>given physical layer: increase power -&gt; increase SNR-&gt;decrease BER</li><li>given SNR: choose physical layer that meets BER requirement, giving highest thruput<ul><li>SNR may change with mobility: dynamically adapt physical layer (modulation technique, rate) </li></ul></li></ul></li></ul><h3 id="7-2-1-CDMA"><a href="#7-2-1-CDMA" class="headerlink" title="7.2.1 CDMA"></a>7.2.1 CDMA</h3><p>Code Division Multiple Access (CDMA)<br>unique “code” assigned to each user; i.e., code set partitioning</p><pre><code>- all users share same frequency, but each user has own “chipping” sequence (i.e., code) to encode data- allows multiple users to “coexist” and transmit simultaneously with minimal interference (if codes are “orthogonal”)</code></pre><ul><li>encoded signal = (original data) X (chipping sequence)</li><li>decoding: inner-product of encoded signal and chipping sequence<blockquote><p>在CDMA协议中，要发送的每个比特都通过乘以一个信号的比特来进行编码，这个信号的变化速率，即码片速率</p><h2 id="7-3-IEEE-802-11-wireless-LANs-“Wi-Fi”"><a href="#7-3-IEEE-802-11-wireless-LANs-“Wi-Fi”" class="headerlink" title="7.3 IEEE 802.11 wireless LANs (“Wi-Fi”)"></a>7.3 IEEE 802.11 wireless LANs (“Wi-Fi”)</h2><p>个人认为这一部分讲的比较零碎，不太好整理，就直接在书上画下来了</p></blockquote></li></ul><h2 id="7-4-Cellular-Internet-access"><a href="#7-4-Cellular-Internet-access" class="headerlink" title="7.4 Cellular Internet access"></a>7.4 Cellular Internet access</h2><h3 id="7-4-1-Components-of-cellular-network-architecture"><a href="#7-4-1-Components-of-cellular-network-architecture" class="headerlink" title="7.4.1 Components of cellular network architecture"></a>7.4.1 Components of cellular network architecture</h3><h4 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h4><ul><li>covers geographical region</li><li>base station (BS) analogous to 802.11 AP</li><li>mobile users attach to network through BS</li><li>air-interface: physical and link layer protocol between mobile and BS</li></ul><h4 id="MSC"><a href="#MSC" class="headerlink" title="MSC"></a>MSC</h4><ul><li>connects cells to wired tel. net.</li><li>manages call setup (more later!)</li><li>handles mobility (more later!)</li></ul><h3 id="7-4-2-Cellular-networks-the-first-hop"><a href="#7-4-2-Cellular-networks-the-first-hop" class="headerlink" title="7.4.2 Cellular networks: the first hop"></a>7.4.2 Cellular networks: the first hop</h3><p>Two techniques for sharing mobile-to-BS radio spectrum</p><ul><li>combined FDMA/TDMA: divide spectrum in frequency channels, divide each channel into time slots</li><li>CDMA: code division multiple access</li></ul><h3 id="7-5-Principles-addressing-and-routing-to-mobile-users"><a href="#7-5-Principles-addressing-and-routing-to-mobile-users" class="headerlink" title="7.5 Principles: addressing and routing to mobile users"></a>7.5 Principles: addressing and routing to mobile users</h3><h3 id="7-6-Mobile-IP"><a href="#7-6-Mobile-IP" class="headerlink" title="7.6 Mobile IP"></a>7.6 Mobile IP</h3><ul><li>RFC 3344</li><li>has many features we’ve seen: <ul><li>home agents, foreign agents, foreign-agent registration, care-of-addresses, encapsulation (packet-within-a-packet)</li></ul></li><li>three components to standard:<ul><li>indirect routing of datagrams</li><li>agent discovery</li><li>registration with home agent</li></ul></li></ul><h2 id="7-7-Handling-mobility-in-cellular-networks"><a href="#7-7-Handling-mobility-in-cellular-networks" class="headerlink" title="7.7 Handling mobility in cellular networks"></a>7.7 Handling mobility in cellular networks</h2><h3 id="7-7-1-Routing-Calls-to-a-Mobile-User"><a href="#7-7-1-Routing-Calls-to-a-Mobile-User" class="headerlink" title="7.7.1 Routing Calls to a Mobile User"></a>7.7.1 Routing Calls to a Mobile User</h3><ul><li>home network: network of cellular provider you subscribe to (e.g., Sprint PCS, Verizon)<ul><li>home location register (HLR): database in home network containing permanent cell phone #, profile information (services, preferences, billing), information about current location (could be in another network)</li></ul></li><li>visited network: network in which mobile currently resides<ul><li>visitor location register (VLR): database with entry for each user currently in network</li><li>could be home network</li></ul></li></ul><h3 id="7-7-2-GSM-handoff-with-common-MSC"><a href="#7-7-2-GSM-handoff-with-common-MSC" class="headerlink" title="7.7.2 GSM: handoff with common MSC"></a>7.7.2 GSM: handoff with common MSC</h3><ul><li>handoff goal: route call via new base station (without interruption)</li><li>reasons for handoff:<ul><li>stronger signal to/from new BSS (continuing connectivity, less battery drain)</li><li>load balance: free up channel in current BSS</li><li>GSM doesn’t mandate why to perform handoff (policy), only how (mechanism)</li></ul></li><li>handoff initiated by old BSS</li></ul><p>GSM: handoff with common MSC</p><ol><li>old BSS informs MSC of impending handoff, provides list of 1+ new BSSs </li><li>MSC sets up path (allocates resources) to new BSS</li><li>new BSS allocates radio channel for use by mobile</li><li>new BSS signals MSC, old BSS: ready </li><li>old BSS tells mobile: perform handoff to new BSS</li><li>mobile, new BSS signal to activate new channel</li><li>mobile signals via new BSS to MSC: handoff complete.  MSC reroutes call</li><li>MSC-old-BSS resources released</li></ol><p>GSM: handoff between MSCs</p><ul><li>anchor MSC: first MSC visited during call<ul><li>call remains routed through anchor MSC</li></ul></li><li>new MSCs add on to end of MSC chain as mobile moves to new MSC</li><li>optional path minimization step to shorten multi-MSC chain<blockquote><p>在一个呼叫过程中，移动站点将其关联从一个基站改变到另一个基站时出现切换。<br>有几种原因导致切换的发生，包括：当前基站和移动用户之间的信号减弱，使该呼叫有被中断风险；一个蜂窝处理的呼叫太多，变得过载。可以通过将一些移动用户切换到临近不太拥塞的蜂窝中，使得拥塞得到缓解。</p><h2 id="7-8-Wireless-mobility-impact-on-higher-layer-protocols"><a href="#7-8-Wireless-mobility-impact-on-higher-layer-protocols" class="headerlink" title="7.8 Wireless, mobility: impact on higher layer protocols"></a>7.8 Wireless, mobility: impact on higher layer protocols</h2></blockquote></li><li>logically, impact should be minimal …<ul><li>best effort service model remains unchanged </li><li>TCP and UDP can (and do) run over wireless, mobile</li></ul></li><li>… but performance-wise:<ul><li>packet loss/delay due to bit-errors (discarded packets, delays for link-layer retransmissions), and handoff</li><li>TCP interprets loss as congestion, will decrease congestion window un-necessarily</li><li>delay impairments for real-time traffic</li><li>limited bandwidth of wireless links</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写在前面: 这门课是我2020年秋季学期上的,当时老师要求读这本书并且做笔记,就留了一下记录.当时看的比较急, 参考了很多翻译, 也参考了这两个项目: &lt;a href=&quot;https://github.com/vincenzobaz/Computer</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://besonn.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://besonn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>The Brand New Start</title>
    <link href="http://besonn.github.io/2021/10/30/The-Brand-New-Start/"/>
    <id>http://besonn.github.io/2021/10/30/The-Brand-New-Start/</id>
    <published>2021-10-30T12:40:24.000Z</published>
    <updated>2021-10-30T12:49:14.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Brand-New-Start"><a href="#The-Brand-New-Start" class="headerlink" title="The Brand New Start"></a>The Brand New Start</h1><p>不知道这是折腾的第几个个人博客了……不出意外的话就不换了，就用这个了。</p><p>第一次捣鼓的时候还是大一，现在都是大四狗了。之前写过的很多文章不打算再同步过来了，只保留在本地，现在就当是重新开始了吧！</p><p>The Brand New Start. 开始在计算机道路上的一段新的折腾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;The-Brand-New-Start&quot;&gt;&lt;a href=&quot;#The-Brand-New-Start&quot; class=&quot;headerlink&quot; title=&quot;The Brand New Start&quot;&gt;&lt;/a&gt;The Brand New Start&lt;/h1&gt;&lt;p&gt;不知</summary>
      
    
    
    
    <category term="随笔" scheme="http://besonn.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 配置</title>
    <link href="http://besonn.github.io/2021/08/10/hexo-%E9%85%8D%E7%BD%AE/"/>
    <id>http://besonn.github.io/2021/08/10/hexo-%E9%85%8D%E7%BD%AE/</id>
    <published>2021-08-10T02:42:04.000Z</published>
    <updated>2022-05-07T13:53:11.887Z</updated>
    
    <content type="html"><![CDATA[<p>换成hexo 配置了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;换成hexo 配置了&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
